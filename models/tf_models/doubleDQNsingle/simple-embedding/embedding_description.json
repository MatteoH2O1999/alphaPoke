{"name": "embedding", "code": "def embedding(self) -> Space:\n    available_moves_space = Box(low=0, high=1, shape=(self.space_size,), dtype=int)\n    return Dict(\n        {\n            \"available_actions\": available_moves_space,\n            \"battlefield\": _BattlefieldEmbedding.get_embedding(),\n            \"active_mon\": _ActivePokemonEmbedding.get_embedding(),\n            \"player_mon_1\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_2\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_3\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_4\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_5\": _PokemonEmbedding.get_embedding(),\n            \"opponent_active_mon\": _EnemyActivePokemonEmbedding.get_embedding(),\n            \"opponent_mon_1\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_2\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_3\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_4\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_5\": _EnemyPokemonEmbedding.get_embedding(),\n        }\n    )\n", "dependencies": ["Union = pickle.loads(b'\\x80\\x04\\x95\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x06typing\\x94\\x8c\\x05Union\\x94\\x93\\x94.')", "ABILITIES = pickle.loads(b'\\x80\\x04\\x95(\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x15utils.get_smogon_data\\x94\\x8c\\nAbilities8\\x94\\x93\\x94.')", "class _MoveFlagsEmbedding:\n    @staticmethod\n    def embed_move_flags(move: Move, opponent: Pokemon):\n        if move is None:\n            return np.full(6, -1, dtype=int)\n        flags = np.full(6, 0, dtype=int)\n        if move.can_z_move:\n            flags[0] = 1\n        if move.thaws_target:\n            flags[1] = 1\n        if move.stalling_move:\n            flags[2] = 1\n        if move.ignore_immunity and opponent is not None:\n            if isinstance(move.ignore_immunity, bool):\n                flags[3] = 1\n            else:\n                for t in opponent.types:\n                    if t in move.ignore_immunity:\n                        flags[3] = 1\n        if move.force_switch:\n            flags[4] = 1\n        if move.breaks_protect:\n            flags[5] = 1\n        return flags\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(6)]\n        high_bound = [1 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "UNKNOWN_ITEM = pickle.loads(b'\\x80\\x04\\x95\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x0cunknown_item\\x94.')", "class _ActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n        available_moves = battle.available_moves[:]\n        if (\n            len(available_moves) > 0\n            and isinstance(available_moves[0], DynamaxMove) != mon.is_dynamaxed\n        ):\n            if isinstance(available_moves[0], DynamaxMove) and not mon.is_dynamaxed:\n                available_moves = [\n                    m._parent for m in available_moves  # noqa: used for bug in poke_env\n                ]\n            elif not isinstance(available_moves[0], DynamaxMove) and mon.is_dynamaxed:\n                available_moves = [m.dynamaxed for m in available_moves]\n        while len(available_moves) < 4:\n            available_moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"effects\": _EffectsEmbedding.embed_effects(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                available_moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                available_moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                available_moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                available_moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"effects\": _EffectsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "ITEMS = pickle.loads(b'\\x80\\x04\\x95#\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x15utils.get_smogon_data\\x94\\x8c\\x05Items\\x94\\x93\\x94.')", "class _EnemyActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n            moves = list(mon.moves.values())\n            for move in moves:\n                if isinstance(move, DynamaxMove) != mon.is_dynamaxed:\n                    moves.remove(move)\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "class _PokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "class _FieldEmbedding:\n    @staticmethod\n    def embed_field(battle: AbstractBattle):\n        fields = np.full(len(Field), 0, dtype=int)\n        battle_fields = battle.fields\n        for field, value in battle_fields.items():\n            fields[field.value - 1] = 1\n        return fields\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Field))]\n        high_bound = [1 for _ in range(len(Field))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _EnemyPokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "class _AbilityEmbedding:\n    @staticmethod\n    def embed_ability(mon: Pokemon):\n        if mon is None:\n            return np.full(len(ABILITIES), -1, dtype=int)\n        battle_abilities = np.full(len(ABILITIES), 0, dtype=int)\n        if not mon.ability:\n            possible_abilities = mon.possible_abilities\n            if len(possible_abilities) == 1:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 2\n            else:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 1\n            return battle_abilities\n        battle_abilities[getattr(ABILITIES, mon.ability).value - 1] = 2\n        return battle_abilities\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ABILITIES))]\n        high_bound = [2 for _ in range(len(ABILITIES))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _BaseStatsEmbedding:\n    @staticmethod\n    def embed_stats(mon: Pokemon):\n        if mon is None:\n            return np.full(6, -1.0, dtype=np.float64)\n        stats = np.full(6, 0.0, dtype=np.float64)\n        stats[0] = mon.base_stats[\"hp\"] / 255\n        stats[1] = mon.base_stats[\"atk\"] / 255\n        stats[2] = mon.base_stats[\"def\"] / 255\n        stats[3] = mon.base_stats[\"spa\"] / 255\n        stats[4] = mon.base_stats[\"spd\"] / 255\n        stats[5] = mon.base_stats[\"spe\"] / 255\n        return stats\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1.0 for _ in range(6)]\n        high_bound = [1.0 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n", "class _ItemEmbedding:\n    @staticmethod\n    def embed_item(mon: Pokemon):\n        if mon is None or not mon.item or mon.item == UNKNOWN_ITEM:\n            return np.full(len(ITEMS), -1, dtype=int)\n        battle_item = mon.item\n        items = np.full(len(ITEMS), 0, dtype=int)\n        items[getattr(ITEMS, battle_item).value - 1] = 1\n        return items\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ITEMS))]\n        high_bound = [1 for _ in range(len(ITEMS))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _StatusEmbedding:\n    @staticmethod\n    def embed_status(mon: Pokemon):\n        if mon is not None:\n            status = mon.status\n            statuses = np.full(len(Status), 0, dtype=int)\n            if status is not None:\n                statuses[status.value - 1] = 1\n        else:\n            statuses = np.full(len(Status), -1, dtype=int)\n        return statuses\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Status))]\n        high_bound = [1 for _ in range(len(Status))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _WeatherEmbedding:\n    @staticmethod\n    def embed_weather(battle: AbstractBattle):\n        weather = battle.weather\n        weathers = np.full(len(Weather), 0, dtype=int)\n        for w, value in weather.items():\n            weathers[w.value - 1] = 1\n        return weathers\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Weather))]\n        high_bound = [1 for _ in range(len(Weather))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _SelfBoostsEmbedding:\n    @staticmethod\n    def embed_self_boosts(move: Move):\n        if move is None:\n            self_boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            self_boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            boosts = {}\n            if move.self_boost is not None:\n                boosts.update(move.self_boost)\n            if move.target == \"self\" and move.boosts is not None:\n                if move.self_boost is not None:\n                    raise RuntimeError(\n                        \"Did not expect self_boosts and boosts to be active at the same time.\"\n                    )\n                boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"self\" in d.keys():\n                    data = d[\"self\"]\n                    boost_chance = d[\"chance\"] / 100\n                    if len(data) == 1 and list(data.keys()) == [\"boosts\"]:\n                        for key, value in data[\"boosts\"].items():\n                            secondary_boosts[key] = (value, boost_chance)\n            for key, value in boosts.items():\n                self_boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                self_boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": self_boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        self_boosts_low_bound = [-7 for _ in range(7)]\n        self_boosts_high_bound = [6 for _ in range(7)]\n        self_boosts_space = Box(\n            low=np.array(self_boosts_low_bound, dtype=int),\n            high=np.array(self_boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": self_boosts_space, \"chances\": chance_space})\n", "STACKABLE_CONDITIONS = pickle.loads(b'\\x80\\x04\\x95O\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c#poke_env.environment.side_condition\\x94\\x8c\\rSideCondition\\x94\\x93\\x94K\\x0f\\x85\\x94R\\x94K\\x03h\\x03K\\x13\\x85\\x94R\\x94K\\x02u.')", "class _MoveCategoryEmbedding:\n    @staticmethod\n    def embed_category(move: Move):\n        if move is None:\n            return np.full(len(MoveCategory), -1, dtype=int)\n        category = np.full(len(MoveCategory), 0, dtype=int)\n        category[move.category.value - 1] = 1\n        return category\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(MoveCategory))]\n        high_bound = [1 for _ in range(len(MoveCategory))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _BoostsEmbedding:\n    @staticmethod\n    def embed_boosts(move: Move):\n        if move is None:\n            boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            move_boosts = {}\n            if move.target != \"self\" and move.boosts is not None:\n                move_boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"boosts\" in d.keys():\n                    secondary_chance = d[\"chance\"] / 100\n                    for key, value in d[\"boosts\"].items():\n                        secondary_boosts[key] = (value, secondary_chance)\n            for key, value in move_boosts.items():\n                boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        boosts_low_bound = [-7 for _ in range(7)]\n        boosts_high_bound = [6 for _ in range(7)]\n        boosts_space = Box(\n            low=np.array(boosts_low_bound, dtype=int),\n            high=np.array(boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": boosts_space, \"chances\": chance_space})\n", "BOOSTS_MULTIPLIERS = pickle.loads(b'\\x80\\x04\\x95^\\x00\\x00\\x00\\x00\\x00\\x00\\x00]\\x94(G?\\xd0\\x00\\x00\\x00\\x00\\x00\\x00G?\\xd1\\xeb\\x85\\x1e\\xb8Q\\xecG?\\xd5\\x1e\\xb8Q\\xeb\\x85\\x1fG?\\xd9\\x99\\x99\\x99\\x99\\x99\\x9aG?\\xe0\\x00\\x00\\x00\\x00\\x00\\x00G?\\xe5\\x1e\\xb8Q\\xeb\\x85\\x1fK\\x01G?\\xf8\\x00\\x00\\x00\\x00\\x00\\x00K\\x02G@\\x04\\x00\\x00\\x00\\x00\\x00\\x00K\\x03G@\\x0c\\x00\\x00\\x00\\x00\\x00\\x00K\\x04e.')", "class _BattlefieldEmbedding:\n    @staticmethod\n    def embed_battlefield(battle: AbstractBattle):\n        dynamax_turns = np.full(2, -1, dtype=int)\n        if battle.dynamax_turns_left is not None:\n            dynamax_turns[0] = battle.dynamax_turns_left\n        if battle.opponent_dynamax_turns_left is not None:\n            dynamax_turns[1] = battle.opponent_dynamax_turns_left\n\n        boolean_flags = np.full(6, 0, dtype=int)\n        if battle.can_mega_evolve:\n            boolean_flags[0] = 1\n        if battle.can_z_move:\n            boolean_flags[1] = 1\n        if battle.can_dynamax:\n            boolean_flags[2] = 1\n        if battle.opponent_can_dynamax:\n            boolean_flags[3] = 1\n        if battle.maybe_trapped:\n            boolean_flags[4] = 1\n        try:\n            forced_switch = any(battle.force_switch)\n        except TypeError:\n            forced_switch = battle.force_switch\n        if forced_switch:\n            boolean_flags[5] = 1\n\n        return {\n            \"dynamax_turns\": dynamax_turns,\n            \"boolean_flags\": boolean_flags,\n            \"fields\": _FieldEmbedding.embed_field(battle),\n            \"side_conditions\": _SideConditionEmbedding.embed_side_conditions(battle),\n            \"weather\": _WeatherEmbedding.embed_weather(battle),\n        }\n\n    @staticmethod\n    def get_embedding():\n        dynamax_turns_low = [-1, -1]\n        dynamax_turns_high = [3, 3]\n        dynamax_turns = Box(\n            low=np.array(dynamax_turns_low, dtype=int),\n            high=np.array(dynamax_turns_high, dtype=int),\n            dtype=int,\n        )\n        boolean_flags = Box(low=0, high=1, shape=(6,), dtype=int)\n        return Dict(\n            {\n                \"dynamax_turns\": dynamax_turns,\n                \"boolean_flags\": boolean_flags,\n                \"fields\": _FieldEmbedding.get_embedding(),\n                \"side_conditions\": _SideConditionEmbedding.get_embedding(),\n                \"weather\": _WeatherEmbedding.get_embedding(),\n            }\n        )\n", "class _MoveEmbedding:\n    @staticmethod\n    def embed_move(move: Move, mon: Pokemon, opponent: Pokemon):\n        if move is None:\n            base_power = -1.0\n            accuracy = -1.0\n            pps = -1.0\n            drain = -1.0\n            heal = -1.0\n            recoil = -1.0\n            damage_multiplier = -1.0\n            min_hits = -1\n            max_hits = -1\n            mean_hits = -1.0\n            crit_ratio = -1\n            priority = -8\n            damage = -1\n        else:\n            base_power = move.base_power / 100\n            accuracy = move.accuracy\n            pps = move.current_pp / move.max_pp\n            drain = move.drain\n            heal = move.heal\n            recoil = move.recoil\n            if opponent is not None:\n                damage_multiplier = opponent.damage_multiplier(move)\n            else:\n                damage_multiplier = -1.0\n            min_hits, max_hits = move.n_hit\n            mean_hits = move.expected_hits\n            crit_ratio = move.crit_ratio\n            priority = move.priority\n            damage = move.damage\n            if damage == \"level\":\n                damage = mon.level\n        float_move_info = np.array(\n            [\n                base_power,\n                accuracy,\n                pps,\n                drain,\n                heal,\n                mean_hits,\n                recoil,\n                damage_multiplier,\n            ],\n            dtype=np.float64,\n        )\n        int_move_info = np.array(\n            [min_hits, max_hits, crit_ratio, priority, damage], dtype=int\n        )\n        return {\n            \"float_move_info\": float_move_info,\n            \"int_move_info\": int_move_info,\n            \"move_category\": _MoveCategoryEmbedding.embed_category(move),\n            \"move_type\": _TypeEmbedding.embed_type(move),\n            \"move_flags\": _MoveFlagsEmbedding.embed_move_flags(move, opponent),\n            \"move_status\": _MoveStatusEmbedding.embed_move_status(move),\n            \"boosts\": _BoostsEmbedding.embed_boosts(move),\n            \"self_boosts\": _SelfBoostsEmbedding.embed_self_boosts(move),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        float_info_low_bound = [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]\n        float_info_high_bound = [4.0, 1.0, 1.0, 1.0, 1.0, 5.23, 1.0, 4.0]\n        #                                                 ^^^^\n        # 5.23 is the expected hit number for triple kick and triple axel\n        #\n        float_info_space = Box(\n            low=np.array(float_info_low_bound, dtype=np.float64),\n            high=np.array(float_info_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        int_info_low_bound = [-1, -1, -1, -8, -1]\n        int_info_high_bound = [5, 5, 6, 5, 100]\n        int_info_space = Box(\n            low=np.array(int_info_low_bound, dtype=int),\n            high=np.array(int_info_high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict(\n            {\n                \"float_move_info\": float_info_space,\n                \"int_move_info\": int_info_space,\n                \"move_category\": _MoveCategoryEmbedding.get_embedding(),\n                \"move_type\": _TypeEmbedding.get_embedding(),\n                \"move_flags\": _MoveFlagsEmbedding.get_embedding(),\n                \"move_status\": _MoveStatusEmbedding.get_embedding(),\n                \"boosts\": _BoostsEmbedding.get_embedding(),\n                \"self_boosts\": _SelfBoostsEmbedding.get_embedding(),\n            }\n        )\n", "STATS = pickle.loads(b'\\x80\\x04\\x95M\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x02hp\\x94K\\x00\\x8c\\x03atk\\x94K\\x01\\x8c\\x03def\\x94K\\x02\\x8c\\x03spa\\x94K\\x03\\x8c\\x03spd\\x94K\\x04\\x8c\\x03spe\\x94K\\x05\\x8c\\x08accuracy\\x94K\\x06\\x8c\\x07evasion\\x94K\\x07u.')", "class _MoveStatusEmbedding:\n    @staticmethod\n    def embed_move_status(move: Move):\n        if move is None:\n            status = np.full(len(Status), -1, dtype=int)\n            chance = np.full(len(Status), -1, dtype=np.float64)\n        else:\n            status = np.full(len(Status), 0, dtype=int)\n            chance = np.full(len(Status), 0, dtype=np.float64)\n            if move.status is not None:\n                status[move.status.value - 1] = 1\n                chance[move.status.value - 1] = 1.0\n            else:\n                secondary = move.secondary\n                for d in secondary:\n                    if \"status\" in d.keys():\n                        secondary_chance = d[\"chance\"] / 100\n                        secondary_status = getattr(Status, d[\"status\"].upper())\n                        status[secondary_status.value - 1] = 1\n                        chance[secondary_status.value - 1] = secondary_chance\n        return {\"status\": status, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        status_low_bound = [-1 for _ in range(len(Status))]\n        status_high_bound = [1 for _ in range(len(Status))]\n        status_space = Box(\n            low=np.array(status_low_bound, dtype=int),\n            high=np.array(status_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(len(Status))]\n        chance_high_bound = [1.0 for _ in range(len(Status))]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"status\": status_space, \"chances\": chance_space})\n", "class _SideConditionEmbedding:\n    @staticmethod\n    def embed_side_conditions(battle: AbstractBattle):\n        battle_side_conditions = battle.side_conditions\n        opponent_battle_side_conditions = battle.opponent_side_conditions\n        side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        opponent_side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        for condition, value in battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                side_conditions[condition.value - 1] = value\n            else:\n                side_conditions[condition.value - 1] = 1\n        for condition, value in opponent_battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                opponent_side_conditions[condition.value - 1] = value\n            else:\n                opponent_side_conditions[condition.value - 1] = 1\n        return {\n            \"player_conditions\": side_conditions,\n            \"opponent_conditions\": opponent_side_conditions,\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(SideCondition))]\n        high_bound = [1 for _ in range(len(SideCondition))]\n        for condition in STACKABLE_CONDITIONS.keys():\n            low_bound[condition.value - 1] = 0\n            high_bound[condition.value - 1] = STACKABLE_CONDITIONS[condition]\n        bound_box = Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict({\"player_conditions\": bound_box, \"opponent_conditions\": bound_box})\n", "class _TypeEmbedding:\n    @staticmethod\n    def embed_type(mon_or_move: Union[Pokemon, Move]):\n        if mon_or_move is None:\n            return np.full(len(PokemonType), -1, dtype=int)\n        types = np.full(len(PokemonType), 0, dtype=int)\n        if isinstance(mon_or_move, Move):\n            battle_types = [mon_or_move.type]\n        elif isinstance(mon_or_move, Pokemon):\n            battle_types = mon_or_move.types\n        else:\n            raise RuntimeError(f\"Expected Move or Pokemon, got {type(mon_or_move)}.\")\n        for mon_type in battle_types:\n            if mon_type is not None:\n                types[mon_type.value - 1] = 1\n        return types\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(PokemonType))]\n        high_bound = [1 for _ in range(len(PokemonType))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _MonBoostsEmbedding:\n    @staticmethod\n    def embed_boosts(mon: Pokemon):\n        if mon is None:\n            return np.full(len(STATS) - 1, -1.0, dtype=np.float64)\n        boosts = np.full(len(STATS) - 1, 1.0, dtype=np.float64)\n        mon_boosts = mon.boosts\n        for boost, boost_value in mon_boosts.items():\n            stat_index = STATS[boost] - 1\n            boost_multiplier = BOOSTS_MULTIPLIERS[boost_value + 6]\n            boosts[stat_index] = boost_multiplier\n        return boosts\n\n    @staticmethod\n    def get_embedding():\n        low_bound = [-1.0 for _ in range(len(STATS) - 1)]\n        high_bound = [4.0 for _ in range(len(STATS) - 1)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n", "class _EffectsEmbedding:\n    @staticmethod\n    def embed_effects(mon: Pokemon):\n        battle_effects = {}\n        if mon is not None:\n            battle_effects = mon.effects\n        effects = np.full(len(Effect), -1, dtype=int)\n        for effect, counter in battle_effects.items():\n            effects[effect.value - 1] = counter\n        return effects\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Effect))]\n        high_bound = [6 for _ in range(len(Effect))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n"], "imports": ["from gym.spaces.space import Space", "from poke_env.environment.weather import Weather", "from poke_env.environment.pokemon_type import PokemonType", "from poke_env.environment.move import Move", "import numpy as np", "from poke_env.environment.field import Field", "from gym.spaces.dict import Dict", "from poke_env.environment.move import DynamaxMove", "from poke_env.environment.pokemon import Pokemon", "from gym.spaces.box import Box", "import os", "from poke_env.environment.abstract_battle import AbstractBattle", "import pickle", "from poke_env.environment.side_condition import SideCondition", "from poke_env.environment.status import Status", "from poke_env.environment.move_category import MoveCategory", "from poke_env.environment.effect import Effect"], "requirements": ["Markdown==3.3.7", "wrapt==1.14.1", "tensorflow-estimator==2.7.0", "tensorflow-cpu==2.7.3", "black==22.6.0", "click==8.1.3", "keras==2.7.0", "tf-agents==0.11.0", "opt-einsum==3.3.0", "typing_extensions==4.3.0", "matplotlib==3.5.2", "pyparsing==3.0.9", "google-auth-oauthlib==0.4.6", "pytest==7.1.2", "cycler==0.11.0", "attrs==21.4.0", "code-extractor==0.1.4", "cloudpickle==2.1.0", "protobuf==3.19.4", "flatbuffers==2.0", "idna==3.3", "orjson==3.7.5", "python-dateutil==2.8.2", "gast==0.4.0", "six==1.16.0", "pyasn1-modules==0.2.8", "pandas==1.4.3", "google-auth==2.9.0", "gym-notices==0.0.7", "platformdirs==2.5.2", "scipy==1.8.1", "pytz==2022.1", "pluggy==1.0.0", "requests==2.28.1", "progress==1.6", "iniconfig==1.1.1", "grpcio==1.47.0", "Keras-Preprocessing==1.1.2", "websockets==10.3", "py==1.11.0", "json5==0.9.8", "coverage==6.4.1", "tensorboard-plugin-wit==1.8.1", "requests-oauthlib==1.3.1", "fonttools==4.33.3", "numpy==1.23.0", "absl-py==1.1.0", "pytest-asyncio==0.18.3", "rsa==4.8", "decorator==5.1.1", "tensorboard-data-server==0.6.1", "tensorflow-probability==0.15.0", "oauthlib==3.2.0", "seaborn==0.11.2", "libclang==14.0.1", "kiwisolver==1.4.3", "termcolor==1.1.0", "charset-normalizer==2.1.0", "cachetools==5.2.0", "gym==0.24.1", "tensorboard==2.9.1", "atomicwrites==1.4.0", "Pillow==9.2.0", "h5py==3.7.0", "tensorflow-io-gcs-filesystem==0.26.0", "gin-config==0.5.0", "astunparse==1.6.3", "urllib3==1.26.9", "poke-env @ git+https://github.com/hsahovic/poke-env.git@9c329e7db397271173755bdce6dc9533c9c94314", "dm-tree==0.1.7", "colorama==0.4.5", "google-pasta==0.2.0", "pathspec==0.9.0", "tomli==2.0.1", "tabulate==0.8.10", "importlib-metadata==4.12.0", "Werkzeug==2.1.2", "mypy-extensions==0.4.3", "certifi==2022.6.15", "packaging==21.3", "zipp==3.8.0", "pyasn1==0.4.8"], "frozen_code": "from gym.spaces.space import Space\nfrom poke_env.environment.weather import Weather\nfrom poke_env.environment.pokemon_type import PokemonType\nfrom poke_env.environment.move import Move\nimport numpy as np\nfrom poke_env.environment.field import Field\nfrom gym.spaces.dict import Dict\nfrom poke_env.environment.move import DynamaxMove\nfrom poke_env.environment.pokemon import Pokemon\nfrom gym.spaces.box import Box\nimport os\nfrom poke_env.environment.abstract_battle import AbstractBattle\nimport pickle\nfrom poke_env.environment.side_condition import SideCondition\nfrom poke_env.environment.status import Status\nfrom poke_env.environment.move_category import MoveCategory\nfrom poke_env.environment.effect import Effect\nUnion = pickle.loads(b'\\x80\\x04\\x95\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x06typing\\x94\\x8c\\x05Union\\x94\\x93\\x94.')\nABILITIES = pickle.loads(b'\\x80\\x04\\x95(\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x15utils.get_smogon_data\\x94\\x8c\\nAbilities8\\x94\\x93\\x94.')\nclass _MoveFlagsEmbedding:\n    @staticmethod\n    def embed_move_flags(move: Move, opponent: Pokemon):\n        if move is None:\n            return np.full(6, -1, dtype=int)\n        flags = np.full(6, 0, dtype=int)\n        if move.can_z_move:\n            flags[0] = 1\n        if move.thaws_target:\n            flags[1] = 1\n        if move.stalling_move:\n            flags[2] = 1\n        if move.ignore_immunity and opponent is not None:\n            if isinstance(move.ignore_immunity, bool):\n                flags[3] = 1\n            else:\n                for t in opponent.types:\n                    if t in move.ignore_immunity:\n                        flags[3] = 1\n        if move.force_switch:\n            flags[4] = 1\n        if move.breaks_protect:\n            flags[5] = 1\n        return flags\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(6)]\n        high_bound = [1 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nUNKNOWN_ITEM = pickle.loads(b'\\x80\\x04\\x95\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x0cunknown_item\\x94.')\nclass _ActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n        available_moves = battle.available_moves[:]\n        if (\n            len(available_moves) > 0\n            and isinstance(available_moves[0], DynamaxMove) != mon.is_dynamaxed\n        ):\n            if isinstance(available_moves[0], DynamaxMove) and not mon.is_dynamaxed:\n                available_moves = [\n                    m._parent for m in available_moves  # noqa: used for bug in poke_env\n                ]\n            elif not isinstance(available_moves[0], DynamaxMove) and mon.is_dynamaxed:\n                available_moves = [m.dynamaxed for m in available_moves]\n        while len(available_moves) < 4:\n            available_moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"effects\": _EffectsEmbedding.embed_effects(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                available_moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                available_moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                available_moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                available_moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"effects\": _EffectsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nITEMS = pickle.loads(b'\\x80\\x04\\x95#\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x15utils.get_smogon_data\\x94\\x8c\\x05Items\\x94\\x93\\x94.')\nclass _EnemyActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n            moves = list(mon.moves.values())\n            for move in moves:\n                if isinstance(move, DynamaxMove) != mon.is_dynamaxed:\n                    moves.remove(move)\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nclass _PokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nclass _FieldEmbedding:\n    @staticmethod\n    def embed_field(battle: AbstractBattle):\n        fields = np.full(len(Field), 0, dtype=int)\n        battle_fields = battle.fields\n        for field, value in battle_fields.items():\n            fields[field.value - 1] = 1\n        return fields\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Field))]\n        high_bound = [1 for _ in range(len(Field))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _EnemyPokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nclass _AbilityEmbedding:\n    @staticmethod\n    def embed_ability(mon: Pokemon):\n        if mon is None:\n            return np.full(len(ABILITIES), -1, dtype=int)\n        battle_abilities = np.full(len(ABILITIES), 0, dtype=int)\n        if not mon.ability:\n            possible_abilities = mon.possible_abilities\n            if len(possible_abilities) == 1:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 2\n            else:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 1\n            return battle_abilities\n        battle_abilities[getattr(ABILITIES, mon.ability).value - 1] = 2\n        return battle_abilities\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ABILITIES))]\n        high_bound = [2 for _ in range(len(ABILITIES))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _BaseStatsEmbedding:\n    @staticmethod\n    def embed_stats(mon: Pokemon):\n        if mon is None:\n            return np.full(6, -1.0, dtype=np.float64)\n        stats = np.full(6, 0.0, dtype=np.float64)\n        stats[0] = mon.base_stats[\"hp\"] / 255\n        stats[1] = mon.base_stats[\"atk\"] / 255\n        stats[2] = mon.base_stats[\"def\"] / 255\n        stats[3] = mon.base_stats[\"spa\"] / 255\n        stats[4] = mon.base_stats[\"spd\"] / 255\n        stats[5] = mon.base_stats[\"spe\"] / 255\n        return stats\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1.0 for _ in range(6)]\n        high_bound = [1.0 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n\nclass _ItemEmbedding:\n    @staticmethod\n    def embed_item(mon: Pokemon):\n        if mon is None or not mon.item or mon.item == UNKNOWN_ITEM:\n            return np.full(len(ITEMS), -1, dtype=int)\n        battle_item = mon.item\n        items = np.full(len(ITEMS), 0, dtype=int)\n        items[getattr(ITEMS, battle_item).value - 1] = 1\n        return items\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ITEMS))]\n        high_bound = [1 for _ in range(len(ITEMS))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _StatusEmbedding:\n    @staticmethod\n    def embed_status(mon: Pokemon):\n        if mon is not None:\n            status = mon.status\n            statuses = np.full(len(Status), 0, dtype=int)\n            if status is not None:\n                statuses[status.value - 1] = 1\n        else:\n            statuses = np.full(len(Status), -1, dtype=int)\n        return statuses\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Status))]\n        high_bound = [1 for _ in range(len(Status))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _WeatherEmbedding:\n    @staticmethod\n    def embed_weather(battle: AbstractBattle):\n        weather = battle.weather\n        weathers = np.full(len(Weather), 0, dtype=int)\n        for w, value in weather.items():\n            weathers[w.value - 1] = 1\n        return weathers\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Weather))]\n        high_bound = [1 for _ in range(len(Weather))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _SelfBoostsEmbedding:\n    @staticmethod\n    def embed_self_boosts(move: Move):\n        if move is None:\n            self_boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            self_boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            boosts = {}\n            if move.self_boost is not None:\n                boosts.update(move.self_boost)\n            if move.target == \"self\" and move.boosts is not None:\n                if move.self_boost is not None:\n                    raise RuntimeError(\n                        \"Did not expect self_boosts and boosts to be active at the same time.\"\n                    )\n                boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"self\" in d.keys():\n                    data = d[\"self\"]\n                    boost_chance = d[\"chance\"] / 100\n                    if len(data) == 1 and list(data.keys()) == [\"boosts\"]:\n                        for key, value in data[\"boosts\"].items():\n                            secondary_boosts[key] = (value, boost_chance)\n            for key, value in boosts.items():\n                self_boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                self_boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": self_boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        self_boosts_low_bound = [-7 for _ in range(7)]\n        self_boosts_high_bound = [6 for _ in range(7)]\n        self_boosts_space = Box(\n            low=np.array(self_boosts_low_bound, dtype=int),\n            high=np.array(self_boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": self_boosts_space, \"chances\": chance_space})\n\nSTACKABLE_CONDITIONS = pickle.loads(b'\\x80\\x04\\x95O\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c#poke_env.environment.side_condition\\x94\\x8c\\rSideCondition\\x94\\x93\\x94K\\x0f\\x85\\x94R\\x94K\\x03h\\x03K\\x13\\x85\\x94R\\x94K\\x02u.')\nclass _MoveCategoryEmbedding:\n    @staticmethod\n    def embed_category(move: Move):\n        if move is None:\n            return np.full(len(MoveCategory), -1, dtype=int)\n        category = np.full(len(MoveCategory), 0, dtype=int)\n        category[move.category.value - 1] = 1\n        return category\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(MoveCategory))]\n        high_bound = [1 for _ in range(len(MoveCategory))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _BoostsEmbedding:\n    @staticmethod\n    def embed_boosts(move: Move):\n        if move is None:\n            boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            move_boosts = {}\n            if move.target != \"self\" and move.boosts is not None:\n                move_boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"boosts\" in d.keys():\n                    secondary_chance = d[\"chance\"] / 100\n                    for key, value in d[\"boosts\"].items():\n                        secondary_boosts[key] = (value, secondary_chance)\n            for key, value in move_boosts.items():\n                boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        boosts_low_bound = [-7 for _ in range(7)]\n        boosts_high_bound = [6 for _ in range(7)]\n        boosts_space = Box(\n            low=np.array(boosts_low_bound, dtype=int),\n            high=np.array(boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": boosts_space, \"chances\": chance_space})\n\nBOOSTS_MULTIPLIERS = pickle.loads(b'\\x80\\x04\\x95^\\x00\\x00\\x00\\x00\\x00\\x00\\x00]\\x94(G?\\xd0\\x00\\x00\\x00\\x00\\x00\\x00G?\\xd1\\xeb\\x85\\x1e\\xb8Q\\xecG?\\xd5\\x1e\\xb8Q\\xeb\\x85\\x1fG?\\xd9\\x99\\x99\\x99\\x99\\x99\\x9aG?\\xe0\\x00\\x00\\x00\\x00\\x00\\x00G?\\xe5\\x1e\\xb8Q\\xeb\\x85\\x1fK\\x01G?\\xf8\\x00\\x00\\x00\\x00\\x00\\x00K\\x02G@\\x04\\x00\\x00\\x00\\x00\\x00\\x00K\\x03G@\\x0c\\x00\\x00\\x00\\x00\\x00\\x00K\\x04e.')\nclass _BattlefieldEmbedding:\n    @staticmethod\n    def embed_battlefield(battle: AbstractBattle):\n        dynamax_turns = np.full(2, -1, dtype=int)\n        if battle.dynamax_turns_left is not None:\n            dynamax_turns[0] = battle.dynamax_turns_left\n        if battle.opponent_dynamax_turns_left is not None:\n            dynamax_turns[1] = battle.opponent_dynamax_turns_left\n\n        boolean_flags = np.full(6, 0, dtype=int)\n        if battle.can_mega_evolve:\n            boolean_flags[0] = 1\n        if battle.can_z_move:\n            boolean_flags[1] = 1\n        if battle.can_dynamax:\n            boolean_flags[2] = 1\n        if battle.opponent_can_dynamax:\n            boolean_flags[3] = 1\n        if battle.maybe_trapped:\n            boolean_flags[4] = 1\n        try:\n            forced_switch = any(battle.force_switch)\n        except TypeError:\n            forced_switch = battle.force_switch\n        if forced_switch:\n            boolean_flags[5] = 1\n\n        return {\n            \"dynamax_turns\": dynamax_turns,\n            \"boolean_flags\": boolean_flags,\n            \"fields\": _FieldEmbedding.embed_field(battle),\n            \"side_conditions\": _SideConditionEmbedding.embed_side_conditions(battle),\n            \"weather\": _WeatherEmbedding.embed_weather(battle),\n        }\n\n    @staticmethod\n    def get_embedding():\n        dynamax_turns_low = [-1, -1]\n        dynamax_turns_high = [3, 3]\n        dynamax_turns = Box(\n            low=np.array(dynamax_turns_low, dtype=int),\n            high=np.array(dynamax_turns_high, dtype=int),\n            dtype=int,\n        )\n        boolean_flags = Box(low=0, high=1, shape=(6,), dtype=int)\n        return Dict(\n            {\n                \"dynamax_turns\": dynamax_turns,\n                \"boolean_flags\": boolean_flags,\n                \"fields\": _FieldEmbedding.get_embedding(),\n                \"side_conditions\": _SideConditionEmbedding.get_embedding(),\n                \"weather\": _WeatherEmbedding.get_embedding(),\n            }\n        )\n\nclass _MoveEmbedding:\n    @staticmethod\n    def embed_move(move: Move, mon: Pokemon, opponent: Pokemon):\n        if move is None:\n            base_power = -1.0\n            accuracy = -1.0\n            pps = -1.0\n            drain = -1.0\n            heal = -1.0\n            recoil = -1.0\n            damage_multiplier = -1.0\n            min_hits = -1\n            max_hits = -1\n            mean_hits = -1.0\n            crit_ratio = -1\n            priority = -8\n            damage = -1\n        else:\n            base_power = move.base_power / 100\n            accuracy = move.accuracy\n            pps = move.current_pp / move.max_pp\n            drain = move.drain\n            heal = move.heal\n            recoil = move.recoil\n            if opponent is not None:\n                damage_multiplier = opponent.damage_multiplier(move)\n            else:\n                damage_multiplier = -1.0\n            min_hits, max_hits = move.n_hit\n            mean_hits = move.expected_hits\n            crit_ratio = move.crit_ratio\n            priority = move.priority\n            damage = move.damage\n            if damage == \"level\":\n                damage = mon.level\n        float_move_info = np.array(\n            [\n                base_power,\n                accuracy,\n                pps,\n                drain,\n                heal,\n                mean_hits,\n                recoil,\n                damage_multiplier,\n            ],\n            dtype=np.float64,\n        )\n        int_move_info = np.array(\n            [min_hits, max_hits, crit_ratio, priority, damage], dtype=int\n        )\n        return {\n            \"float_move_info\": float_move_info,\n            \"int_move_info\": int_move_info,\n            \"move_category\": _MoveCategoryEmbedding.embed_category(move),\n            \"move_type\": _TypeEmbedding.embed_type(move),\n            \"move_flags\": _MoveFlagsEmbedding.embed_move_flags(move, opponent),\n            \"move_status\": _MoveStatusEmbedding.embed_move_status(move),\n            \"boosts\": _BoostsEmbedding.embed_boosts(move),\n            \"self_boosts\": _SelfBoostsEmbedding.embed_self_boosts(move),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        float_info_low_bound = [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]\n        float_info_high_bound = [4.0, 1.0, 1.0, 1.0, 1.0, 5.23, 1.0, 4.0]\n        #                                                 ^^^^\n        # 5.23 is the expected hit number for triple kick and triple axel\n        #\n        float_info_space = Box(\n            low=np.array(float_info_low_bound, dtype=np.float64),\n            high=np.array(float_info_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        int_info_low_bound = [-1, -1, -1, -8, -1]\n        int_info_high_bound = [5, 5, 6, 5, 100]\n        int_info_space = Box(\n            low=np.array(int_info_low_bound, dtype=int),\n            high=np.array(int_info_high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict(\n            {\n                \"float_move_info\": float_info_space,\n                \"int_move_info\": int_info_space,\n                \"move_category\": _MoveCategoryEmbedding.get_embedding(),\n                \"move_type\": _TypeEmbedding.get_embedding(),\n                \"move_flags\": _MoveFlagsEmbedding.get_embedding(),\n                \"move_status\": _MoveStatusEmbedding.get_embedding(),\n                \"boosts\": _BoostsEmbedding.get_embedding(),\n                \"self_boosts\": _SelfBoostsEmbedding.get_embedding(),\n            }\n        )\n\nSTATS = pickle.loads(b'\\x80\\x04\\x95M\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x02hp\\x94K\\x00\\x8c\\x03atk\\x94K\\x01\\x8c\\x03def\\x94K\\x02\\x8c\\x03spa\\x94K\\x03\\x8c\\x03spd\\x94K\\x04\\x8c\\x03spe\\x94K\\x05\\x8c\\x08accuracy\\x94K\\x06\\x8c\\x07evasion\\x94K\\x07u.')\nclass _MoveStatusEmbedding:\n    @staticmethod\n    def embed_move_status(move: Move):\n        if move is None:\n            status = np.full(len(Status), -1, dtype=int)\n            chance = np.full(len(Status), -1, dtype=np.float64)\n        else:\n            status = np.full(len(Status), 0, dtype=int)\n            chance = np.full(len(Status), 0, dtype=np.float64)\n            if move.status is not None:\n                status[move.status.value - 1] = 1\n                chance[move.status.value - 1] = 1.0\n            else:\n                secondary = move.secondary\n                for d in secondary:\n                    if \"status\" in d.keys():\n                        secondary_chance = d[\"chance\"] / 100\n                        secondary_status = getattr(Status, d[\"status\"].upper())\n                        status[secondary_status.value - 1] = 1\n                        chance[secondary_status.value - 1] = secondary_chance\n        return {\"status\": status, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        status_low_bound = [-1 for _ in range(len(Status))]\n        status_high_bound = [1 for _ in range(len(Status))]\n        status_space = Box(\n            low=np.array(status_low_bound, dtype=int),\n            high=np.array(status_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(len(Status))]\n        chance_high_bound = [1.0 for _ in range(len(Status))]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"status\": status_space, \"chances\": chance_space})\n\nclass _SideConditionEmbedding:\n    @staticmethod\n    def embed_side_conditions(battle: AbstractBattle):\n        battle_side_conditions = battle.side_conditions\n        opponent_battle_side_conditions = battle.opponent_side_conditions\n        side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        opponent_side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        for condition, value in battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                side_conditions[condition.value - 1] = value\n            else:\n                side_conditions[condition.value - 1] = 1\n        for condition, value in opponent_battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                opponent_side_conditions[condition.value - 1] = value\n            else:\n                opponent_side_conditions[condition.value - 1] = 1\n        return {\n            \"player_conditions\": side_conditions,\n            \"opponent_conditions\": opponent_side_conditions,\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(SideCondition))]\n        high_bound = [1 for _ in range(len(SideCondition))]\n        for condition in STACKABLE_CONDITIONS.keys():\n            low_bound[condition.value - 1] = 0\n            high_bound[condition.value - 1] = STACKABLE_CONDITIONS[condition]\n        bound_box = Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict({\"player_conditions\": bound_box, \"opponent_conditions\": bound_box})\n\nclass _TypeEmbedding:\n    @staticmethod\n    def embed_type(mon_or_move: Union[Pokemon, Move]):\n        if mon_or_move is None:\n            return np.full(len(PokemonType), -1, dtype=int)\n        types = np.full(len(PokemonType), 0, dtype=int)\n        if isinstance(mon_or_move, Move):\n            battle_types = [mon_or_move.type]\n        elif isinstance(mon_or_move, Pokemon):\n            battle_types = mon_or_move.types\n        else:\n            raise RuntimeError(f\"Expected Move or Pokemon, got {type(mon_or_move)}.\")\n        for mon_type in battle_types:\n            if mon_type is not None:\n                types[mon_type.value - 1] = 1\n        return types\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(PokemonType))]\n        high_bound = [1 for _ in range(len(PokemonType))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _MonBoostsEmbedding:\n    @staticmethod\n    def embed_boosts(mon: Pokemon):\n        if mon is None:\n            return np.full(len(STATS) - 1, -1.0, dtype=np.float64)\n        boosts = np.full(len(STATS) - 1, 1.0, dtype=np.float64)\n        mon_boosts = mon.boosts\n        for boost, boost_value in mon_boosts.items():\n            stat_index = STATS[boost] - 1\n            boost_multiplier = BOOSTS_MULTIPLIERS[boost_value + 6]\n            boosts[stat_index] = boost_multiplier\n        return boosts\n\n    @staticmethod\n    def get_embedding():\n        low_bound = [-1.0 for _ in range(len(STATS) - 1)]\n        high_bound = [4.0 for _ in range(len(STATS) - 1)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n\nclass _EffectsEmbedding:\n    @staticmethod\n    def embed_effects(mon: Pokemon):\n        battle_effects = {}\n        if mon is not None:\n            battle_effects = mon.effects\n        effects = np.full(len(Effect), -1, dtype=int)\n        for effect, counter in battle_effects.items():\n            effects[effect.value - 1] = counter\n        return effects\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Effect))]\n        high_bound = [6 for _ in range(len(Effect))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\ndef embedding(self) -> Space:\n    available_moves_space = Box(low=0, high=1, shape=(self.space_size,), dtype=int)\n    return Dict(\n        {\n            \"available_actions\": available_moves_space,\n            \"battlefield\": _BattlefieldEmbedding.get_embedding(),\n            \"active_mon\": _ActivePokemonEmbedding.get_embedding(),\n            \"player_mon_1\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_2\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_3\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_4\": _PokemonEmbedding.get_embedding(),\n            \"player_mon_5\": _PokemonEmbedding.get_embedding(),\n            \"opponent_active_mon\": _EnemyActivePokemonEmbedding.get_embedding(),\n            \"opponent_mon_1\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_2\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_3\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_4\": _EnemyPokemonEmbedding.get_embedding(),\n            \"opponent_mon_5\": _EnemyPokemonEmbedding.get_embedding(),\n        }\n    )\n"}