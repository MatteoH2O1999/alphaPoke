{"name": "embed_battle", "code": "def embed_battle(self, battle: AbstractBattle) -> ObservationType:\n    non_active_player_mons = battle.available_switches[:]\n    non_active_opponent_mons = list(battle.opponent_team.values())\n    non_active_opponent_mons.remove(battle.opponent_active_pokemon)\n    while len(non_active_player_mons) < 5:\n        non_active_player_mons.append(None)  # noqa: used for variable length teams\n    while len(non_active_opponent_mons) < 5:\n        non_active_opponent_mons.append(None)\n    available_moves = np.full(self.space_size, 1, dtype=int)\n    int_to_move_func = self.action_to_move_func\n    for i in range(len(available_moves)):\n        try:\n            int_to_move_func(self, i, battle, InvalidAction)\n        except InvalidAction:\n            available_moves[i] = 0\n    return {\n        \"available_actions\": available_moves,\n        \"battlefield\": _BattlefieldEmbedding.embed_battlefield(battle),\n        \"active_mon\": _ActivePokemonEmbedding.embed_pokemon(\n            battle.active_pokemon, battle\n        ),\n        \"player_mon_1\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[0], battle\n        ),\n        \"player_mon_2\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[1], battle\n        ),\n        \"player_mon_3\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[2], battle\n        ),\n        \"player_mon_4\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[3], battle\n        ),\n        \"player_mon_5\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[4], battle\n        ),\n        \"opponent_active_mon\": _EnemyActivePokemonEmbedding.embed_pokemon(\n            battle.opponent_active_pokemon, battle\n        ),\n        \"opponent_mon_1\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[0], battle\n        ),\n        \"opponent_mon_2\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[1], battle\n        ),\n        \"opponent_mon_3\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[2], battle\n        ),\n        \"opponent_mon_4\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[3], battle\n        ),\n        \"opponent_mon_5\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[4], battle\n        ),\n    }\n", "dependencies": ["Weather = enum.Enum(value='Weather', names=[('_UNKNOWN', 1), ('DESOLATELAND', 2), ('DELTASTREAM', 3), ('HAIL', 4), ('PRIMORDIALSEA', 5), ('RAINDANCE', 6), ('SANDSTORM', 7), ('SUNNYDAY', 8)])\n", "class _StatusEmbedding:\n    @staticmethod\n    def embed_status(mon: Pokemon):\n        if mon is not None:\n            status = mon.status\n            statuses = np.full(len(Status), 0, dtype=int)\n            if status is not None:\n                statuses[Status[status.name].value - 1] = 1\n        else:\n            statuses = np.full(len(Status), -1, dtype=int)\n        return statuses\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Status))]\n        high_bound = [1 for _ in range(len(Status))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "ABILITIES = enum.Enum(value='ABILITIES', names=[('adaptability', 1), ('aerilate', 2), ('aftermath', 3), ('airlock', 4), ('analytic', 5), ('angerpoint', 6), ('anticipation', 7), ('arenatrap', 8), ('aromaveil', 9), ('asoneglastrier', 10), ('asonespectrier', 11), ('aurabreak', 12), ('baddreams', 13), ('ballfetch', 14), ('battery', 15), ('battlearmor', 16), ('battlebond', 17), ('beastboost', 18), ('berserk', 19), ('bigpecks', 20), ('blaze', 21), ('bulletproof', 22), ('cheekpouch', 23), ('chillingneigh', 24), ('chlorophyll', 25), ('clearbody', 26), ('cloudnine', 27), ('colorchange', 28), ('comatose', 29), ('competitive', 30), ('compoundeyes', 31), ('contrary', 32), ('corrosion', 33), ('cottondown', 34), ('curiousmedicine', 35), ('cursedbody', 36), ('cutecharm', 37), ('damp', 38), ('dancer', 39), ('darkaura', 40), ('dauntlessshield', 41), ('dazzling', 42), ('defeatist', 43), ('defiant', 44), ('deltastream', 45), ('desolateland', 46), ('disguise', 47), ('download', 48), ('dragonsmaw', 49), ('drizzle', 50), ('drought', 51), ('dryskin', 52), ('earlybird', 53), ('effectspore', 54), ('electricsurge', 55), ('emergencyexit', 56), ('fairyaura', 57), ('filter', 58), ('flamebody', 59), ('flareboost', 60), ('flashfire', 61), ('flowergift', 62), ('flowerveil', 63), ('fluffy', 64), ('forecast', 65), ('forewarn', 66), ('friendguard', 67), ('frisk', 68), ('fullmetalbody', 69), ('furcoat', 70), ('galewings', 71), ('galvanize', 72), ('gluttony', 73), ('gooey', 74), ('gorillatactics', 75), ('grasspelt', 76), ('grassysurge', 77), ('grimneigh', 78), ('gulpmissile', 79), ('guts', 80), ('harvest', 81), ('healer', 82), ('heatproof', 83), ('heavymetal', 84), ('honeygather', 85), ('hugepower', 86), ('hungerswitch', 87), ('hustle', 88), ('hydration', 89), ('hypercutter', 90), ('icebody', 91), ('iceface', 92), ('icescales', 93), ('illuminate', 94), ('illusion', 95), ('immunity', 96), ('imposter', 97), ('infiltrator', 98), ('innardsout', 99), ('innerfocus', 100), ('insomnia', 101), ('intimidate', 102), ('intrepidsword', 103), ('ironbarbs', 104), ('ironfist', 105), ('justified', 106), ('keeneye', 107), ('klutz', 108), ('leafguard', 109), ('levitate', 110), ('libero', 111), ('lightmetal', 112), ('lightningrod', 113), ('limber', 114), ('liquidooze', 115), ('liquidvoice', 116), ('longreach', 117), ('magicbounce', 118), ('magicguard', 119), ('magician', 120), ('magmaarmor', 121), ('magnetpull', 122), ('marvelscale', 123), ('megalauncher', 124), ('merciless', 125), ('mimicry', 126), ('minus', 127), ('mirrorarmor', 128), ('mistysurge', 129), ('moldbreaker', 130), ('moody', 131), ('motordrive', 132), ('mountaineer', 133), ('moxie', 134), ('multiscale', 135), ('multitype', 136), ('mummy', 137), ('naturalcure', 138), ('neuroforce', 139), ('neutralizinggas', 140), ('noguard', 141), ('normalize', 142), ('oblivious', 143), ('overcoat', 144), ('overgrow', 145), ('owntempo', 146), ('parentalbond', 147), ('pastelveil', 148), ('perishbody', 149), ('persistent', 150), ('pickpocket', 151), ('pickup', 152), ('pixilate', 153), ('plus', 154), ('poisonheal', 155), ('poisonpoint', 156), ('poisontouch', 157), ('powerconstruct', 158), ('powerofalchemy', 159), ('powerspot', 160), ('prankster', 161), ('pressure', 162), ('primordialsea', 163), ('prismarmor', 164), ('propellertail', 165), ('protean', 166), ('psychicsurge', 167), ('punkrock', 168), ('purepower', 169), ('queenlymajesty', 170), ('quickdraw', 171), ('quickfeet', 172), ('raindish', 173), ('rattled', 174), ('rebound', 175), ('receiver', 176), ('reckless', 177), ('refrigerate', 178), ('regenerator', 179), ('ripen', 180), ('rivalry', 181), ('rkssystem', 182), ('rockhead', 183), ('roughskin', 184), ('runaway', 185), ('sandforce', 186), ('sandrush', 187), ('sandspit', 188), ('sandstream', 189), ('sandveil', 190), ('sapsipper', 191), ('schooling', 192), ('scrappy', 193), ('screencleaner', 194), ('serenegrace', 195), ('shadowshield', 196), ('shadowtag', 197), ('shedskin', 198), ('sheerforce', 199), ('shellarmor', 200), ('shielddust', 201), ('shieldsdown', 202), ('simple', 203), ('skilllink', 204), ('slowstart', 205), ('slushrush', 206), ('sniper', 207), ('snowcloak', 208), ('snowwarning', 209), ('solarpower', 210), ('solidrock', 211), ('soulheart', 212), ('soundproof', 213), ('speedboost', 214), ('stakeout', 215), ('stall', 216), ('stalwart', 217), ('stamina', 218), ('stancechange', 219), ('static', 220), ('steadfast', 221), ('steamengine', 222), ('steelworker', 223), ('steelyspirit', 224), ('stench', 225), ('stickyhold', 226), ('stormdrain', 227), ('strongjaw', 228), ('sturdy', 229), ('suctioncups', 230), ('superluck', 231), ('surgesurfer', 232), ('swarm', 233), ('sweetveil', 234), ('swiftswim', 235), ('symbiosis', 236), ('synchronize', 237), ('tangledfeet', 238), ('tanglinghair', 239), ('technician', 240), ('telepathy', 241), ('teravolt', 242), ('thickfat', 243), ('tintedlens', 244), ('torrent', 245), ('toughclaws', 246), ('toxicboost', 247), ('trace', 248), ('transistor', 249), ('triage', 250), ('truant', 251), ('turboblaze', 252), ('unaware', 253), ('unburden', 254), ('unnerve', 255), ('unseenfist', 256), ('victorystar', 257), ('vitalspirit', 258), ('voltabsorb', 259), ('wanderingspirit', 260), ('waterabsorb', 261), ('waterbubble', 262), ('watercompaction', 263), ('waterveil', 264), ('weakarmor', 265), ('whitesmoke', 266), ('wimpout', 267), ('wonderguard', 268), ('wonderskin', 269), ('zenmode', 270)])\n", "Union = pickle.loads(b'\\x80\\x04\\x95\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x06typing\\x94\\x8c\\x05Union\\x94\\x93\\x94.')", "class InvalidAction(Exception):\n    pass\n", "class _WeatherEmbedding:\n    @staticmethod\n    def embed_weather(battle: AbstractBattle):\n        weather = battle.weather\n        weathers = np.full(len(Weather), 0, dtype=int)\n        for w, value in weather.items():\n            weathers[Weather[w.name].value - 1] = 1\n        return weathers\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Weather))]\n        high_bound = [1 for _ in range(len(Weather))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _MoveStatusEmbedding:\n    @staticmethod\n    def embed_move_status(move: Move):\n        if move is None:\n            status = np.full(len(Status), -1, dtype=int)\n            chance = np.full(len(Status), -1, dtype=np.float64)\n        else:\n            status = np.full(len(Status), 0, dtype=int)\n            chance = np.full(len(Status), 0, dtype=np.float64)\n            if move.status is not None:\n                status[Status[move.status.name].value - 1] = 1\n                chance[Status[move.status.name].value - 1] = 1.0\n            else:\n                secondary = move.secondary\n                for d in secondary:\n                    if \"status\" in d.keys():\n                        secondary_chance = d[\"chance\"] / 100\n                        secondary_status = getattr(Status, d[\"status\"].upper())\n                        status[secondary_status.value - 1] = 1\n                        chance[secondary_status.value - 1] = secondary_chance\n        return {\"status\": status, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        status_low_bound = [-1 for _ in range(len(Status))]\n        status_high_bound = [1 for _ in range(len(Status))]\n        status_space = Box(\n            low=np.array(status_low_bound, dtype=int),\n            high=np.array(status_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(len(Status))]\n        chance_high_bound = [1.0 for _ in range(len(Status))]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"status\": status_space, \"chances\": chance_space})\n", "class _MoveCategoryEmbedding:\n    @staticmethod\n    def embed_category(move: Move):\n        if move is None:\n            return np.full(len(MoveCategory), -1, dtype=int)\n        category = np.full(len(MoveCategory), 0, dtype=int)\n        category[MoveCategory[move.category.name].value - 1] = 1\n        return category\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(MoveCategory))]\n        high_bound = [1 for _ in range(len(MoveCategory))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _PokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "class _EnemyPokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "ObservationType = pickle.loads(b'\\x80\\x04\\x952\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x1apoke_env.player.openai_api\\x94\\x8c\\x0fObservationType\\x94\\x93\\x94.')", "class _ItemEmbedding:\n    @staticmethod\n    def embed_item(mon: Pokemon):\n        if mon is None or not mon.item or mon.item == UNKNOWN_ITEM:\n            return np.full(len(ITEMS), -1, dtype=int)\n        battle_item = mon.item\n        items = np.full(len(ITEMS), 0, dtype=int)\n        items[getattr(ITEMS, battle_item).value - 1] = 1\n        return items\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ITEMS))]\n        high_bound = [1 for _ in range(len(ITEMS))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "STATS = {'hp': 0, 'atk': 1, 'def': 2, 'spa': 3, 'spd': 4, 'spe': 5, 'accuracy': 6, 'evasion': 7}\n", "poke_env.environment.side_condition.SideCondition = enum.Enum(value='SideCondition', module='poke_env.environment.side_condition', names=[('_UNKNOWN', 1), ('AURORA_VEIL', 2), ('FIRE_PLEDGE', 3), ('G_MAX_CANNONADE', 4), ('G_MAX_STEELSURGE', 5), ('G_MAX_VINE_LASH', 6), ('G_MAX_VOLCALITH', 7), ('G_MAX_WILDFIRE', 8), ('GRASS_PLEDGE', 9), ('LIGHT_SCREEN', 10), ('LUCKY_CHANT', 11), ('MIST', 12), ('REFLECT', 13), ('SAFEGUARD', 14), ('SPIKES', 15), ('STEALTH_ROCK', 16), ('STICKY_WEB', 17), ('TAILWIND', 18), ('TOXIC_SPIKES', 19), ('WATER_PLEDGE', 20)])\n", "class _FieldEmbedding:\n    @staticmethod\n    def embed_field(battle: AbstractBattle):\n        fields = np.full(len(Field), 0, dtype=int)\n        battle_fields = battle.fields\n        for field, value in battle_fields.items():\n            fields[Field[field.name].value - 1] = 1\n        return fields\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Field))]\n        high_bound = [1 for _ in range(len(Field))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "SideCondition = enum.Enum(value='SideCondition', names=[('_UNKNOWN', 1), ('AURORA_VEIL', 2), ('FIRE_PLEDGE', 3), ('G_MAX_CANNONADE', 4), ('G_MAX_STEELSURGE', 5), ('G_MAX_VINE_LASH', 6), ('G_MAX_VOLCALITH', 7), ('G_MAX_WILDFIRE', 8), ('GRASS_PLEDGE', 9), ('LIGHT_SCREEN', 10), ('LUCKY_CHANT', 11), ('MIST', 12), ('REFLECT', 13), ('SAFEGUARD', 14), ('SPIKES', 15), ('STEALTH_ROCK', 16), ('STICKY_WEB', 17), ('TAILWIND', 18), ('TOXIC_SPIKES', 19), ('WATER_PLEDGE', 20)])\n", "MoveCategory = enum.Enum(value='MoveCategory', names=[('PHYSICAL', 1), ('SPECIAL', 2), ('STATUS', 3)])\n", "class _EffectsEmbedding:\n    @staticmethod\n    def embed_effects(mon: Pokemon):\n        battle_effects = {}\n        if mon is not None:\n            battle_effects = mon.effects\n        effects = np.full(len(Effect), -1, dtype=int)\n        for effect, counter in battle_effects.items():\n            effects[Effect[effect.name].value - 1] = counter\n        return effects\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Effect))]\n        high_bound = [6 for _ in range(len(Effect))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "Status = enum.Enum(value='Status', names=[('BRN', 1), ('FNT', 2), ('FRZ', 3), ('PAR', 4), ('PSN', 5), ('SLP', 6), ('TOX', 7)])\n", "class _MoveFlagsEmbedding:\n    @staticmethod\n    def embed_move_flags(move: Move, opponent: Pokemon):\n        if move is None:\n            return np.full(6, -1, dtype=int)\n        flags = np.full(6, 0, dtype=int)\n        if move.can_z_move:\n            flags[0] = 1\n        if move.thaws_target:\n            flags[1] = 1\n        if move.stalling_move:\n            flags[2] = 1\n        if move.ignore_immunity and opponent is not None:\n            if isinstance(move.ignore_immunity, bool):\n                flags[3] = 1\n            else:\n                for t in opponent.types:\n                    if t in move.ignore_immunity:\n                        flags[3] = 1\n        if move.force_switch:\n            flags[4] = 1\n        if move.breaks_protect:\n            flags[5] = 1\n        return flags\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(6)]\n        high_bound = [1 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "STACKABLE_CONDITIONS = {poke_env.environment.side_condition.SideCondition.SPIKES: 3, poke_env.environment.side_condition.SideCondition.TOXIC_SPIKES: 2}\n", "PokemonType = enum.Enum(value='PokemonType', names=[('BUG', 1), ('DARK', 2), ('DRAGON', 3), ('ELECTRIC', 4), ('FAIRY', 5), ('FIGHTING', 6), ('FIRE', 7), ('FLYING', 8), ('GHOST', 9), ('GRASS', 10), ('GROUND', 11), ('ICE', 12), ('NORMAL', 13), ('POISON', 14), ('PSYCHIC', 15), ('ROCK', 16), ('STEEL', 17), ('WATER', 18)])\n", "class _MoveEmbedding:\n    @staticmethod\n    def embed_move(move: Move, mon: Pokemon, opponent: Pokemon):\n        if move is None:\n            base_power = -1.0\n            accuracy = -1.0\n            pps = -1.0\n            drain = -1.0\n            heal = -1.0\n            recoil = -1.0\n            damage_multiplier = -1.0\n            min_hits = -1\n            max_hits = -1\n            mean_hits = -1.0\n            crit_ratio = -1\n            priority = -8\n            damage = -1\n        else:\n            base_power = move.base_power / 100\n            accuracy = move.accuracy\n            pps = move.current_pp / move.max_pp\n            drain = move.drain\n            heal = move.heal\n            recoil = move.recoil\n            if opponent is not None:\n                damage_multiplier = opponent.damage_multiplier(move)\n            else:\n                damage_multiplier = -1.0\n            min_hits, max_hits = move.n_hit\n            mean_hits = move.expected_hits\n            crit_ratio = move.crit_ratio\n            priority = move.priority\n            damage = move.damage\n            if damage == \"level\":\n                damage = mon.level\n        float_move_info = np.array(\n            [\n                base_power,\n                accuracy,\n                pps,\n                drain,\n                heal,\n                mean_hits,\n                recoil,\n                damage_multiplier,\n            ],\n            dtype=np.float64,\n        )\n        int_move_info = np.array(\n            [min_hits, max_hits, crit_ratio, priority, damage], dtype=int\n        )\n        return {\n            \"float_move_info\": float_move_info,\n            \"int_move_info\": int_move_info,\n            \"move_category\": _MoveCategoryEmbedding.embed_category(move),\n            \"move_type\": _TypeEmbedding.embed_type(move),\n            \"move_flags\": _MoveFlagsEmbedding.embed_move_flags(move, opponent),\n            \"move_status\": _MoveStatusEmbedding.embed_move_status(move),\n            \"boosts\": _BoostsEmbedding.embed_boosts(move),\n            \"self_boosts\": _SelfBoostsEmbedding.embed_self_boosts(move),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        float_info_low_bound = [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]\n        float_info_high_bound = [4.0, 1.0, 1.0, 1.0, 1.0, 5.23, 1.0, 4.0]\n        #                                                 ^^^^\n        # 5.23 is the expected hit number for triple kick and triple axel\n        #\n        float_info_space = Box(\n            low=np.array(float_info_low_bound, dtype=np.float64),\n            high=np.array(float_info_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        int_info_low_bound = [-1, -1, -1, -8, -1]\n        int_info_high_bound = [5, 5, 6, 5, 100]\n        int_info_space = Box(\n            low=np.array(int_info_low_bound, dtype=int),\n            high=np.array(int_info_high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict(\n            {\n                \"float_move_info\": float_info_space,\n                \"int_move_info\": int_info_space,\n                \"move_category\": _MoveCategoryEmbedding.get_embedding(),\n                \"move_type\": _TypeEmbedding.get_embedding(),\n                \"move_flags\": _MoveFlagsEmbedding.get_embedding(),\n                \"move_status\": _MoveStatusEmbedding.get_embedding(),\n                \"boosts\": _BoostsEmbedding.get_embedding(),\n                \"self_boosts\": _SelfBoostsEmbedding.get_embedding(),\n            }\n        )\n", "Effect = enum.Enum(value='Effect', names=[('_UNKNOWN', 1), ('AFTER_YOU', 2), ('AFTERMATH', 3), ('AQUA_RING', 4), ('AROMATHERAPY', 5), ('AROMA_VEIL', 6), ('ATTRACT', 7), ('AUTOTOMIZE', 8), ('BAD_DREAMS', 9), ('BANEFUL_BUNKER', 10), ('BATTLE_BOND', 11), ('BIDE', 12), ('BIND', 13), ('BURN_UP', 14), ('CELEBRATE', 15), ('CHARGE', 16), ('CLAMP', 17), ('CONFUSION', 18), ('COURT_CHANGE', 19), ('CRAFTY_SHIELD', 20), ('CURSE', 21), ('CUSTAP_BERRY', 22), ('DANCER', 23), ('DESTINY_BOND', 24), ('DISABLE', 25), ('DISGUISE', 26), ('DOOM_DESIRE', 27), ('DYNAMAX', 28), ('EERIE_SPELL', 29), ('ELECTRIC_TERRAIN', 30), ('EMBARGO', 31), ('EMERGENCY_EXIT', 32), ('ENCORE', 33), ('ENDURE', 34), ('FAIRY_LOCK', 35), ('FEINT', 36), ('FIRE_SPIN', 37), ('FLASH_FIRE', 38), ('FLOWER_VEIL', 39), ('FOCUS_BAND', 40), ('FOCUS_ENERGY', 41), ('FORESIGHT', 42), ('FOREWARN', 43), ('FUTURE_SIGHT', 44), ('G_MAX_CENTIFERNO', 45), ('G_MAX_CHI_STRIKE', 46), ('G_MAX_ONE_BLOW', 47), ('G_MAX_RAPID_FLOW', 48), ('G_MAX_SANDBLAST', 49), ('GRAVITY', 50), ('GRUDGE', 51), ('GUARD_SPLIT', 52), ('GULP_MISSILE', 53), ('HEAL_BELL', 54), ('HEAL_BLOCK', 55), ('HEALER', 56), ('HYDRATION', 57), ('HYPERSPACE_FURY', 58), ('HYPERSPACE_HOLE', 59), ('ICE_FACE', 60), ('ILLUSION', 61), ('IMMUNITY', 62), ('IMPRISON', 63), ('INFESTATION', 64), ('INGRAIN', 65), ('INNARDS_OUT', 66), ('INSOMNIA', 67), ('IRON_BARBS', 68), ('LASER_FOCUS', 69), ('LEECH_SEED', 70), ('LIGHTNING_ROD', 71), ('LIMBER', 72), ('LIQUID_OOZE', 73), ('LOCK_ON', 74), ('MAGMA_STORM', 75), ('MAGNET_RISE', 76), ('MAGNITUDE', 77), ('MAT_BLOCK', 78), ('MAX_GUARD', 79), ('MIMIC', 80), ('MIMICRY', 81), ('MIND_READER', 82), ('MINIMIZE', 83), ('MIRACLE_EYE', 84), ('MIST', 85), ('MISTY_TERRAIN', 86), ('MUMMY', 87), ('NEUTRALIZING_GAS', 88), ('NIGHTMARE', 89), ('NO_RETREAT', 90), ('OBLIVIOUS', 91), ('OCTOLOCK', 92), ('OWN_TEMPO', 93), ('PASTEL_VEIL', 94), ('PERISH0', 95), ('PERISH1', 96), ('PERISH2', 97), ('PERISH3', 98), ('PHANTOM_FORCE', 99), ('POLTERGEIST', 100), ('POWDER', 101), ('POWER_CONSTRUCT', 102), ('POWER_SPLIT', 103), ('POWER_TRICK', 104), ('PROTECT', 105), ('PROTECTIVE_PADS', 106), ('PSYCHIC_TERRAIN', 107), ('PURSUIT', 108), ('QUASH', 109), ('QUICK_CLAW', 110), ('QUICK_GUARD', 111), ('REFLECT', 112), ('RIPEN', 113), ('ROUGH_SKIN', 114), ('SAFEGUARD', 115), ('SAFETY_GOGGLES', 116), ('SAND_TOMB', 117), ('SCREEN_CLEANER', 118), ('SHADOW_FORCE', 119), ('SHED_SKIN', 120), ('SKETCH', 121), ('SKILL_SWAP', 122), ('SKY_DROP', 123), ('SLOW_START', 124), ('SMACK_DOWN', 125), ('SNAP_TRAP', 126), ('SNATCH', 127), ('SPEED_SWAP', 128), ('SPITE', 129), ('STICKY_HOLD', 130), ('STICKY_WEB', 131), ('STOCKPILE', 132), ('STOCKPILE1', 133), ('STOCKPILE2', 134), ('STOCKPILE3', 135), ('STORM_DRAIN', 136), ('STRUGGLE', 137), ('SUBSTITUTE', 138), ('SUCTION_CUPS', 139), ('SWEET_VEIL', 140), ('SYMBIOSIS', 141), ('SYNCHRONIZE', 142), ('TAR_SHOT', 143), ('TAUNT', 144), ('TELEKINESIS', 145), ('TELEPATHY', 146), ('THROAT_CHOP', 147), ('THUNDER_CAGE', 148), ('TORMENT', 149), ('TRAPPED', 150), ('TRICK', 151), ('TYPEADD', 152), ('TYPECHANGE', 153), ('TYPE_CHANGE', 154), ('UPROAR', 155), ('VITAL_SPIRIT', 156), ('WANDERING_SPIRIT', 157), ('WATER_BUBBLE', 158), ('WATER_VEIL', 159), ('WHIRLPOOL', 160), ('WIDE_GUARD', 161), ('WIMP_OUT', 162), ('WRAP', 163), ('YAWN', 164)])\n", "class _EnemyActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n            moves = list(mon.moves.values())\n            for move in moves:\n                if isinstance(move, DynamaxMove) != mon.is_dynamaxed:\n                    moves.remove(move)\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "Field = enum.Enum(value='Field', names=[('_UNKNOWN', 1), ('ELECTRIC_TERRAIN', 2), ('GRASSY_TERRAIN', 3), ('GRAVITY', 4), ('HEAL_BLOCK', 5), ('MAGIC_ROOM', 6), ('MISTY_TERRAIN', 7), ('MUD_SPORT', 8), ('MUD_SPOT', 9), ('PSYCHIC_TERRAIN', 10), ('TRICK_ROOM', 11), ('WATER_SPORT', 12), ('WONDER_ROOM', 13)])\n", "class _BaseStatsEmbedding:\n    @staticmethod\n    def embed_stats(mon: Pokemon):\n        if mon is None:\n            return np.full(6, -1.0, dtype=np.float64)\n        stats = np.full(6, 0.0, dtype=np.float64)\n        stats[0] = mon.base_stats[\"hp\"] / 255\n        stats[1] = mon.base_stats[\"atk\"] / 255\n        stats[2] = mon.base_stats[\"def\"] / 255\n        stats[3] = mon.base_stats[\"spa\"] / 255\n        stats[4] = mon.base_stats[\"spd\"] / 255\n        stats[5] = mon.base_stats[\"spe\"] / 255\n        return stats\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1.0 for _ in range(6)]\n        high_bound = [1.0 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n", "class _MonBoostsEmbedding:\n    @staticmethod\n    def embed_boosts(mon: Pokemon):\n        if mon is None:\n            return np.full(len(STATS) - 1, -1.0, dtype=np.float64)\n        boosts = np.full(len(STATS) - 1, 1.0, dtype=np.float64)\n        mon_boosts = mon.boosts\n        for boost, boost_value in mon_boosts.items():\n            stat_index = STATS[boost] - 1\n            boost_multiplier = BOOSTS_MULTIPLIERS[boost_value + 6]\n            boosts[stat_index] = boost_multiplier\n        return boosts\n\n    @staticmethod\n    def get_embedding():\n        low_bound = [-1.0 for _ in range(len(STATS) - 1)]\n        high_bound = [4.0 for _ in range(len(STATS) - 1)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n", "ITEMS = enum.Enum(value='ITEMS', names=[('abomasite', 1), ('absolite', 2), ('absorbbulb', 3), ('adamantorb', 4), ('adrenalineorb', 5), ('aerodactylite', 6), ('aggronite', 7), ('aguavberry', 8), ('airballoon', 9), ('alakazite', 10), ('aloraichiumz', 11), ('altarianite', 12), ('ampharosite', 13), ('apicotberry', 14), ('armorfossil', 15), ('aspearberry', 16), ('assaultvest', 17), ('audinite', 18), ('babiriberry', 19), ('banettite', 20), ('beastball', 21), ('beedrillite', 22), ('belueberry', 23), ('berry', 24), ('berryjuice', 25), ('berrysweet', 26), ('berserkgene', 27), ('bigroot', 28), ('bindingband', 29), ('bitterberry', 30), ('blackbelt', 31), ('blackglasses', 32), ('blacksludge', 33), ('blastoisinite', 34), ('blazikenite', 35), ('blueorb', 36), ('blukberry', 37), ('blunderpolicy', 38), ('bottlecap', 39), ('brightpowder', 40), ('buggem', 41), ('buginiumz', 42), ('bugmemory', 43), ('burndrive', 44), ('burntberry', 45), ('cameruptite', 46), ('cellbattery', 47), ('charcoal', 48), ('charizarditex', 49), ('charizarditey', 50), ('chartiberry', 51), ('cheriberry', 52), ('cherishball', 53), ('chestoberry', 54), ('chilanberry', 55), ('chilldrive', 56), ('chippedpot', 57), ('choiceband', 58), ('choicescarf', 59), ('choicespecs', 60), ('chopleberry', 61), ('clawfossil', 62), ('cloversweet', 63), ('cobaberry', 64), ('colburberry', 65), ('cornnberry', 66), ('coverfossil', 67), ('crackedpot', 68), ('crucibellite', 69), ('custapberry', 70), ('damprock', 71), ('darkgem', 72), ('darkiniumz', 73), ('darkmemory', 74), ('dawnstone', 75), ('decidiumz', 76), ('deepseascale', 77), ('deepseatooth', 78), ('destinyknot', 79), ('diancite', 80), ('diveball', 81), ('domefossil', 82), ('dousedrive', 83), ('dracoplate', 84), ('dragonfang', 85), ('dragongem', 86), ('dragoniumz', 87), ('dragonmemory', 88), ('dragonscale', 89), ('dreadplate', 90), ('dreamball', 91), ('dubiousdisc', 92), ('durinberry', 93), ('duskball', 94), ('duskstone', 95), ('earthplate', 96), ('eeviumz', 97), ('ejectbutton', 98), ('ejectpack', 99), ('electirizer', 100), ('electricgem', 101), ('electricmemory', 102), ('electricseed', 103), ('electriumz', 104), ('energypowder', 105), ('enigmaberry', 106), ('eviolite', 107), ('expertbelt', 108), ('fairiumz', 109), ('fairygem', 110), ('fairymemory', 111), ('fastball', 112), ('fightinggem', 113), ('fightingmemory', 114), ('fightiniumz', 115), ('figyberry', 116), ('firegem', 117), ('firememory', 118), ('firestone', 119), ('firiumz', 120), ('fistplate', 121), ('flameorb', 122), ('flameplate', 123), ('floatstone', 124), ('flowersweet', 125), ('flyinggem', 126), ('flyingmemory', 127), ('flyiniumz', 128), ('focusband', 129), ('focussash', 130), ('fossilizedbird', 131), ('fossilizeddino', 132), ('fossilizeddrake', 133), ('fossilizedfish', 134), ('friendball', 135), ('fullincense', 136), ('galladite', 137), ('ganlonberry', 138), ('garchompite', 139), ('gardevoirite', 140), ('gengarite', 141), ('ghostgem', 142), ('ghostiumz', 143), ('ghostmemory', 144), ('glalitite', 145), ('goldberry', 146), ('goldbottlecap', 147), ('grassgem', 148), ('grassiumz', 149), ('grassmemory', 150), ('grassyseed', 151), ('greatball', 152), ('grepaberry', 153), ('gripclaw', 154), ('griseousorb', 155), ('groundgem', 156), ('groundiumz', 157), ('groundmemory', 158), ('gyaradosite', 159), ('habanberry', 160), ('hardstone', 161), ('healball', 162), ('heatrock', 163), ('heavyball', 164), ('heavydutyboots', 165), ('helixfossil', 166), ('heracronite', 167), ('hondewberry', 168), ('houndoominite', 169), ('iapapaberry', 170), ('iceberry', 171), ('icegem', 172), ('icememory', 173), ('icestone', 174), ('icicleplate', 175), ('iciumz', 176), ('icyrock', 177), ('inciniumz', 178), ('insectplate', 179), ('ironball', 180), ('ironplate', 181), ('jabocaberry', 182), ('jawfossil', 183), ('kangaskhanite', 184), ('kasibberry', 185), ('kebiaberry', 186), ('keeberry', 187), ('kelpsyberry', 188), ('kingsrock', 189), ('kommoniumz', 190), ('laggingtail', 191), ('lansatberry', 192), ('latiasite', 193), ('latiosite', 194), ('laxincense', 195), ('leafstone', 196), ('leek', 197), ('leftovers', 198), ('leppaberry', 199), ('levelball', 200), ('liechiberry', 201), ('lifeorb', 202), ('lightball', 203), ('lightclay', 204), ('lopunnite', 205), ('loveball', 206), ('lovesweet', 207), ('lucarionite', 208), ('luckypunch', 209), ('lumberry', 210), ('luminousmoss', 211), ('lunaliumz', 212), ('lureball', 213), ('lustrousorb', 214), ('luxuryball', 215), ('lycaniumz', 216), ('machobrace', 217), ('magmarizer', 218), ('magnet', 219), ('magoberry', 220), ('magostberry', 221), ('mail', 222), ('manectite', 223), ('marangaberry', 224), ('marshadiumz', 225), ('masterball', 226), ('mawilite', 227), ('meadowplate', 228), ('medichamite', 229), ('mentalherb', 230), ('metagrossite', 231), ('metalcoat', 232), ('metalpowder', 233), ('metronome', 234), ('mewniumz', 235), ('mewtwonitex', 236), ('mewtwonitey', 237), ('micleberry', 238), ('mimikiumz', 239), ('mindplate', 240), ('mintberry', 241), ('miracleberry', 242), ('miracleseed', 243), ('mistyseed', 244), ('moonball', 245), ('moonstone', 246), ('muscleband', 247), ('mysteryberry', 248), ('mysticwater', 249), ('nanabberry', 250), ('nestball', 251), ('netball', 252), ('nevermeltice', 253), ('nomelberry', 254), ('normalgem', 255), ('normaliumz', 256), ('occaberry', 257), ('oddincense', 258), ('oldamber', 259), ('oranberry', 260), ('ovalstone', 261), ('pamtreberry', 262), ('parkball', 263), ('passhoberry', 264), ('payapaberry', 265), ('pechaberry', 266), ('persimberry', 267), ('petayaberry', 268), ('pidgeotite', 269), ('pikaniumz', 270), ('pikashuniumz', 271), ('pinapberry', 272), ('pinkbow', 273), ('pinsirite', 274), ('pixieplate', 275), ('plumefossil', 276), ('poisonbarb', 277), ('poisongem', 278), ('poisoniumz', 279), ('poisonmemory', 280), ('pokeball', 281), ('polkadotbow', 282), ('pomegberry', 283), ('poweranklet', 284), ('powerband', 285), ('powerbelt', 286), ('powerbracer', 287), ('powerherb', 288), ('powerlens', 289), ('powerweight', 290), ('premierball', 291), ('primariumz', 292), ('prismscale', 293), ('protectivepads', 294), ('protector', 295), ('przcureberry', 296), ('psncureberry', 297), ('psychicgem', 298), ('psychicmemory', 299), ('psychicseed', 300), ('psychiumz', 301), ('qualotberry', 302), ('quickball', 303), ('quickclaw', 304), ('quickpowder', 305), ('rabutaberry', 306), ('rarebone', 307), ('rawstberry', 308), ('razorclaw', 309), ('razorfang', 310), ('razzberry', 311), ('reapercloth', 312), ('redcard', 313), ('redorb', 314), ('repeatball', 315), ('ribbonsweet', 316), ('rindoberry', 317), ('ringtarget', 318), ('rockgem', 319), ('rockincense', 320), ('rockiumz', 321), ('rockmemory', 322), ('rockyhelmet', 323), ('roomservice', 324), ('rootfossil', 325), ('roseincense', 326), ('roseliberry', 327), ('rowapberry', 328), ('rustedshield', 329), ('rustedsword', 330), ('sablenite', 331), ('sachet', 332), ('safariball', 333), ('safetygoggles', 334), ('sailfossil', 335), ('salacberry', 336), ('salamencite', 337), ('sceptilite', 338), ('scizorite', 339), ('scopelens', 340), ('seaincense', 341), ('sharpbeak', 342), ('sharpedonite', 343), ('shedshell', 344), ('shellbell', 345), ('shinystone', 346), ('shockdrive', 347), ('shucaberry', 348), ('silkscarf', 349), ('silverpowder', 350), ('sitrusberry', 351), ('skullfossil', 352), ('skyplate', 353), ('slowbronite', 354), ('smoothrock', 355), ('snorliumz', 356), ('snowball', 357), ('softsand', 358), ('solganiumz', 359), ('souldew', 360), ('spelltag', 361), ('spelonberry', 362), ('splashplate', 363), ('spookyplate', 364), ('sportball', 365), ('starfberry', 366), ('starsweet', 367), ('steelgem', 368), ('steeliumz', 369), ('steelixite', 370), ('steelmemory', 371), ('stick', 372), ('stickybarb', 373), ('stoneplate', 374), ('strawberrysweet', 375), ('sunstone', 376), ('swampertite', 377), ('sweetapple', 378), ('tamatoberry', 379), ('tangaberry', 380), ('tapuniumz', 381), ('tartapple', 382), ('terrainextender', 383), ('thickclub', 384), ('throatspray', 385), ('thunderstone', 386), ('timerball', 387), ('toxicorb', 388), ('toxicplate', 389), ('tr00', 390), ('tr01', 391), ('tr02', 392), ('tr03', 393), ('tr04', 394), ('tr05', 395), ('tr06', 396), ('tr07', 397), ('tr08', 398), ('tr09', 399), ('tr10', 400), ('tr11', 401), ('tr12', 402), ('tr13', 403), ('tr14', 404), ('tr15', 405), ('tr16', 406), ('tr17', 407), ('tr18', 408), ('tr19', 409), ('tr20', 410), ('tr21', 411), ('tr22', 412), ('tr23', 413), ('tr24', 414), ('tr25', 415), ('tr26', 416), ('tr27', 417), ('tr28', 418), ('tr29', 419), ('tr30', 420), ('tr31', 421), ('tr32', 422), ('tr33', 423), ('tr34', 424), ('tr35', 425), ('tr36', 426), ('tr37', 427), ('tr38', 428), ('tr39', 429), ('tr40', 430), ('tr41', 431), ('tr42', 432), ('tr43', 433), ('tr44', 434), ('tr45', 435), ('tr46', 436), ('tr47', 437), ('tr48', 438), ('tr49', 439), ('tr50', 440), ('tr51', 441), ('tr52', 442), ('tr53', 443), ('tr54', 444), ('tr55', 445), ('tr56', 446), ('tr57', 447), ('tr58', 448), ('tr59', 449), ('tr60', 450), ('tr61', 451), ('tr62', 452), ('tr63', 453), ('tr64', 454), ('tr65', 455), ('tr66', 456), ('tr67', 457), ('tr68', 458), ('tr69', 459), ('tr70', 460), ('tr71', 461), ('tr72', 462), ('tr73', 463), ('tr74', 464), ('tr75', 465), ('tr76', 466), ('tr77', 467), ('tr78', 468), ('tr79', 469), ('tr80', 470), ('tr81', 471), ('tr82', 472), ('tr83', 473), ('tr84', 474), ('tr85', 475), ('tr86', 476), ('tr87', 477), ('tr88', 478), ('tr89', 479), ('tr90', 480), ('tr91', 481), ('tr92', 482), ('tr93', 483), ('tr94', 484), ('tr95', 485), ('tr96', 486), ('tr97', 487), ('tr98', 488), ('tr99', 489), ('twistedspoon', 490), ('tyranitarite', 491), ('ultraball', 492), ('ultranecroziumz', 493), ('upgrade', 494), ('utilityumbrella', 495), ('venusaurite', 496), ('wacanberry', 497), ('watergem', 498), ('wateriumz', 499), ('watermemory', 500), ('waterstone', 501), ('watmelberry', 502), ('waveincense', 503), ('weaknesspolicy', 504), ('wepearberry', 505), ('whippeddream', 506), ('whiteherb', 507), ('widelens', 508), ('wikiberry', 509), ('wiseglasses', 510), ('yacheberry', 511), ('zapplate', 512), ('zoomlens', 513)])\n", "UNKNOWN_ITEM = 'unknown_item'\n", "class _SideConditionEmbedding:\n    @staticmethod\n    def embed_side_conditions(battle: AbstractBattle):\n        battle_side_conditions = battle.side_conditions\n        opponent_battle_side_conditions = battle.opponent_side_conditions\n        side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        opponent_side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        for condition, value in battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                side_conditions[SideCondition[condition.name].value - 1] = value\n            else:\n                side_conditions[SideCondition[condition.name].value - 1] = 1\n        for condition, value in opponent_battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                opponent_side_conditions[\n                    SideCondition[condition.name].value - 1\n                ] = value\n            else:\n                opponent_side_conditions[SideCondition[condition.name].value - 1] = 1\n        return {\n            \"player_conditions\": side_conditions,\n            \"opponent_conditions\": opponent_side_conditions,\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(SideCondition))]\n        high_bound = [1 for _ in range(len(SideCondition))]\n        for condition in STACKABLE_CONDITIONS.keys():\n            low_bound[SideCondition[condition.name].value - 1] = 0\n            high_bound[SideCondition[condition.name].value - 1] = STACKABLE_CONDITIONS[\n                condition\n            ]\n        bound_box = Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict({\"player_conditions\": bound_box, \"opponent_conditions\": bound_box})\n", "class _AbilityEmbedding:\n    @staticmethod\n    def embed_ability(mon: Pokemon):\n        if mon is None:\n            return np.full(len(ABILITIES), -1, dtype=int)\n        battle_abilities = np.full(len(ABILITIES), 0, dtype=int)\n        if not mon.ability:\n            possible_abilities = mon.possible_abilities\n            if len(possible_abilities) == 1:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 2\n            else:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 1\n            return battle_abilities\n        battle_abilities[getattr(ABILITIES, mon.ability).value - 1] = 2\n        return battle_abilities\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ABILITIES))]\n        high_bound = [2 for _ in range(len(ABILITIES))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "class _BoostsEmbedding:\n    @staticmethod\n    def embed_boosts(move: Move):\n        if move is None:\n            boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            move_boosts = {}\n            if move.target != \"self\" and move.boosts is not None:\n                move_boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"boosts\" in d.keys():\n                    secondary_chance = d[\"chance\"] / 100\n                    for key, value in d[\"boosts\"].items():\n                        secondary_boosts[key] = (value, secondary_chance)\n            for key, value in move_boosts.items():\n                boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        boosts_low_bound = [-7 for _ in range(7)]\n        boosts_high_bound = [6 for _ in range(7)]\n        boosts_space = Box(\n            low=np.array(boosts_low_bound, dtype=int),\n            high=np.array(boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": boosts_space, \"chances\": chance_space})\n", "class _TypeEmbedding:\n    @staticmethod\n    def embed_type(mon_or_move: Union[Pokemon, Move]):\n        if mon_or_move is None:\n            return np.full(len(PokemonType), -1, dtype=int)\n        types = np.full(len(PokemonType), 0, dtype=int)\n        if isinstance(mon_or_move, Move):\n            battle_types = [mon_or_move.type]\n        elif isinstance(mon_or_move, Pokemon):\n            battle_types = mon_or_move.types\n        else:\n            raise RuntimeError(f\"Expected Move or Pokemon, got {type(mon_or_move)}.\")\n        for mon_type in battle_types:\n            if mon_type is not None:\n                types[PokemonType[mon_type.name].value - 1] = 1\n        return types\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(PokemonType))]\n        high_bound = [1 for _ in range(len(PokemonType))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n", "BOOSTS_MULTIPLIERS = [0.25, 0.28, 0.33, 0.4, 0.5, 0.66, 1, 1.5, 2, 2.5, 3, 3.5, 4]\n", "class _BattlefieldEmbedding:\n    @staticmethod\n    def embed_battlefield(battle: AbstractBattle):\n        dynamax_turns = np.full(2, -1, dtype=int)\n        if battle.dynamax_turns_left is not None:\n            dynamax_turns[0] = battle.dynamax_turns_left\n        if battle.opponent_dynamax_turns_left is not None:\n            dynamax_turns[1] = battle.opponent_dynamax_turns_left\n\n        boolean_flags = np.full(6, 0, dtype=int)\n        if battle.can_mega_evolve:\n            boolean_flags[0] = 1\n        if battle.can_z_move:\n            boolean_flags[1] = 1\n        if battle.can_dynamax:\n            boolean_flags[2] = 1\n        if battle.opponent_can_dynamax:\n            boolean_flags[3] = 1\n        if battle.maybe_trapped:\n            boolean_flags[4] = 1\n        try:\n            forced_switch = any(battle.force_switch)\n        except TypeError:\n            forced_switch = battle.force_switch\n        if forced_switch:\n            boolean_flags[5] = 1\n\n        return {\n            \"dynamax_turns\": dynamax_turns,\n            \"boolean_flags\": boolean_flags,\n            \"fields\": _FieldEmbedding.embed_field(battle),\n            \"side_conditions\": _SideConditionEmbedding.embed_side_conditions(battle),\n            \"weather\": _WeatherEmbedding.embed_weather(battle),\n        }\n\n    @staticmethod\n    def get_embedding():\n        dynamax_turns_low = [-1, -1]\n        dynamax_turns_high = [3, 3]\n        dynamax_turns = Box(\n            low=np.array(dynamax_turns_low, dtype=int),\n            high=np.array(dynamax_turns_high, dtype=int),\n            dtype=int,\n        )\n        boolean_flags = Box(low=0, high=1, shape=(6,), dtype=int)\n        return Dict(\n            {\n                \"dynamax_turns\": dynamax_turns,\n                \"boolean_flags\": boolean_flags,\n                \"fields\": _FieldEmbedding.get_embedding(),\n                \"side_conditions\": _SideConditionEmbedding.get_embedding(),\n                \"weather\": _WeatherEmbedding.get_embedding(),\n            }\n        )\n", "class _ActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n        available_moves = battle.available_moves[:]\n        if (\n            len(available_moves) > 0\n            and isinstance(available_moves[0], DynamaxMove) != mon.is_dynamaxed\n        ):\n            if isinstance(available_moves[0], DynamaxMove) and not mon.is_dynamaxed:\n                available_moves = [\n                    m._parent for m in available_moves  # noqa: used for bug in poke_env\n                ]\n            elif not isinstance(available_moves[0], DynamaxMove) and mon.is_dynamaxed:\n                available_moves = [m.dynamaxed for m in available_moves]\n        while len(available_moves) < 4:\n            available_moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"effects\": _EffectsEmbedding.embed_effects(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                available_moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                available_moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                available_moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                available_moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"effects\": _EffectsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n", "class _SelfBoostsEmbedding:\n    @staticmethod\n    def embed_self_boosts(move: Move):\n        if move is None:\n            self_boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            self_boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            boosts = {}\n            if move.self_boost is not None:\n                boosts.update(move.self_boost)\n            if move.target == \"self\" and move.boosts is not None:\n                if move.self_boost is not None:\n                    raise RuntimeError(\n                        \"Did not expect self_boosts and boosts to be active at the same time.\"\n                    )\n                boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"self\" in d.keys():\n                    data = d[\"self\"]\n                    boost_chance = d[\"chance\"] / 100\n                    if len(data) == 1 and list(data.keys()) == [\"boosts\"]:\n                        for key, value in data[\"boosts\"].items():\n                            secondary_boosts[key] = (value, boost_chance)\n            for key, value in boosts.items():\n                self_boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                self_boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": self_boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        self_boosts_low_bound = [-7 for _ in range(7)]\n        self_boosts_high_bound = [6 for _ in range(7)]\n        self_boosts_space = Box(\n            low=np.array(self_boosts_low_bound, dtype=int),\n            high=np.array(self_boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": self_boosts_space, \"chances\": chance_space})\n"], "imports": ["from gym.spaces.space import Space", "from poke_env.environment.abstract_battle import AbstractBattle", "from gym.spaces.box import Box", "import enum", "from poke_env.environment.move import Move", "import poke_env.environment.side_condition", "import numpy as np", "from poke_env.environment.pokemon import Pokemon", "from gym.spaces.dict import Dict", "import os", "from poke_env.environment.move import DynamaxMove", "import pickle"], "requirements": ["gast==0.4.0", "absl-py==1.1.0", "gym==0.23.0", "libclang==14.0.1", "pure-eval==0.2.2", "pywin32==304", "oauthlib==3.2.0", "nbconvert==7.1.0", "widgetsnbextension==4.0.3", "nbformat==5.6.1", "tabulate==0.9.0", "scipy==1.8.1", "tornado==6.2", "importlib-metadata==4.12.0", "tensorboard-plugin-wit==1.8.1", "jupyter==1.0.0", "pytz==2022.1", "code-extractor==0.4.1", "charset-normalizer==2.1.0", "bleach==5.0.1", "protobuf==4.23.4", "typing_extensions==4.3.0", "defusedxml==0.7.1", "mistune==2.0.4", "orjson==3.7.5", "atomicwrites==1.4.0", "nest-asyncio==1.5.6", "tensorflow-io-gcs-filesystem==0.26.0", "tensorflow-probability==0.19.0", "tensorflow-estimator==2.12.0", "exceptiongroup==1.1.2", "soupsieve==2.3.2.post1", "termcolor==1.1.0", "QtPy==2.2.1", "urllib3==1.26.9", "backcall==0.2.0", "pathspec==0.9.0", "terminado==0.16.0", "rsa==4.8", "wcwidth==0.2.5", "fastjsonschema==2.16.2", "ipython==8.5.0", "idna==3.3", "python-dateutil==2.8.2", "Send2Trash==1.8.0", "beautifulsoup4==4.11.1", "cachetools==5.2.0", "cffi==1.15.1", "jupyter-core==4.11.1", "flatbuffers==23.5.26", "grpcio==1.56.0", "matplotlib-inline==0.1.6", "pandas==1.4.3", "tinycss2==1.1.1", "fonttools==4.33.3", "psutil==5.9.2", "matplotlib==3.7.2", "jsonschema==4.16.0", "numpy==1.24.3", "Jinja2==3.1.2", "json5==0.9.14", "jupyterlab-widgets==3.0.3", "pytest-asyncio==0.21.0", "colorama==0.4.5", "websockets==10.3", "ipykernel==6.16.0", "asttokens==2.0.8", "h5py==3.7.0", "tf-agents==0.16.0", "black==23.1.0", "mypy-extensions==0.4.3", "debugpy==1.6.3", "tensorflow-cpu==2.12.1", "traitlets==5.4.0", "keras==2.12.0", "wrapt==1.14.1", "nbclient==0.6.8", "attrs==21.4.0", "MarkupSafe==2.1.1", "ml-dtypes==0.2.0", "argon2-cffi==21.3.0", "ipywidgets==8.0.2", "Markdown==3.3.7", "pytest==7.4.0", "poke-env @ git+https://github.com/MatteoH2O1999/poke-env@c5e1fcb3a6dcdcc3868ccb7a720772fa5221d591", "progress==1.6", "pygame==2.1.3", "jupyterlab-pygments==0.2.2", "tensorboard-data-server==0.7.1", "google-pasta==0.2.0", "pluggy==1.0.0", "google-auth-oauthlib==1.0.0", "coverage==7.2.7", "pickleshare==0.7.5", "seaborn==0.12.2", "pandocfilters==1.5.0", "entrypoints==0.4", "notebook==6.4.12", "gin-config==0.5.0", "py==1.11.0", "pycparser==2.21", "requests==2.31.0", "pyparsing==3.0.9", "cycler==0.11.0", "packaging==23.0", "jedi==0.18.1", "click==8.1.3", "prompt-toolkit==3.0.31", "requests-oauthlib==1.3.1", "platformdirs==2.5.2", "gym-notices==0.0.7", "pyasn1-modules==0.2.8", "qtconsole==5.3.2", "six==1.16.0", "decorator==5.1.1", "kiwisolver==1.4.3", "contourpy==1.1.0", "stack-data==0.5.1", "Keras-Preprocessing==1.1.2", "executing==1.1.0", "astunparse==1.6.3", "pyzmq==24.0.1", "certifi==2022.6.15", "opt-einsum==3.3.0", "Pygments==2.13.0", "Pillow==9.2.0", "google-auth==2.21.0", "iniconfig==1.1.1", "webencodings==0.5.1", "jax==0.4.13", "cloudpickle==2.1.0", "Werkzeug==2.1.2", "parso==0.8.3", "jupyter-console==6.4.4", "tomli==2.0.1", "tensorflow-intel==2.12.1", "zipp==3.8.0", "pyasn1==0.4.8", "pywinpty==2.0.8", "jupyter_client==7.3.5", "prometheus-client==0.14.1", "tensorboard==2.12.3", "argon2-cffi-bindings==21.2.0", "pyrsistent==0.18.1", "dm-tree==0.1.7", "ipython-genutils==0.2.0", "importlib-resources==6.0.0"], "frozen_code": "from gym.spaces.space import Space\nfrom poke_env.environment.abstract_battle import AbstractBattle\nfrom gym.spaces.box import Box\nimport enum\nfrom poke_env.environment.move import Move\nimport poke_env.environment.side_condition\nimport numpy as np\nfrom poke_env.environment.pokemon import Pokemon\nfrom gym.spaces.dict import Dict\nimport os\nfrom poke_env.environment.move import DynamaxMove\nimport pickle\nWeather = enum.Enum(value='Weather', names=[('_UNKNOWN', 1), ('DESOLATELAND', 2), ('DELTASTREAM', 3), ('HAIL', 4), ('PRIMORDIALSEA', 5), ('RAINDANCE', 6), ('SANDSTORM', 7), ('SUNNYDAY', 8)])\n\nclass _StatusEmbedding:\n    @staticmethod\n    def embed_status(mon: Pokemon):\n        if mon is not None:\n            status = mon.status\n            statuses = np.full(len(Status), 0, dtype=int)\n            if status is not None:\n                statuses[Status[status.name].value - 1] = 1\n        else:\n            statuses = np.full(len(Status), -1, dtype=int)\n        return statuses\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Status))]\n        high_bound = [1 for _ in range(len(Status))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nABILITIES = enum.Enum(value='ABILITIES', names=[('adaptability', 1), ('aerilate', 2), ('aftermath', 3), ('airlock', 4), ('analytic', 5), ('angerpoint', 6), ('anticipation', 7), ('arenatrap', 8), ('aromaveil', 9), ('asoneglastrier', 10), ('asonespectrier', 11), ('aurabreak', 12), ('baddreams', 13), ('ballfetch', 14), ('battery', 15), ('battlearmor', 16), ('battlebond', 17), ('beastboost', 18), ('berserk', 19), ('bigpecks', 20), ('blaze', 21), ('bulletproof', 22), ('cheekpouch', 23), ('chillingneigh', 24), ('chlorophyll', 25), ('clearbody', 26), ('cloudnine', 27), ('colorchange', 28), ('comatose', 29), ('competitive', 30), ('compoundeyes', 31), ('contrary', 32), ('corrosion', 33), ('cottondown', 34), ('curiousmedicine', 35), ('cursedbody', 36), ('cutecharm', 37), ('damp', 38), ('dancer', 39), ('darkaura', 40), ('dauntlessshield', 41), ('dazzling', 42), ('defeatist', 43), ('defiant', 44), ('deltastream', 45), ('desolateland', 46), ('disguise', 47), ('download', 48), ('dragonsmaw', 49), ('drizzle', 50), ('drought', 51), ('dryskin', 52), ('earlybird', 53), ('effectspore', 54), ('electricsurge', 55), ('emergencyexit', 56), ('fairyaura', 57), ('filter', 58), ('flamebody', 59), ('flareboost', 60), ('flashfire', 61), ('flowergift', 62), ('flowerveil', 63), ('fluffy', 64), ('forecast', 65), ('forewarn', 66), ('friendguard', 67), ('frisk', 68), ('fullmetalbody', 69), ('furcoat', 70), ('galewings', 71), ('galvanize', 72), ('gluttony', 73), ('gooey', 74), ('gorillatactics', 75), ('grasspelt', 76), ('grassysurge', 77), ('grimneigh', 78), ('gulpmissile', 79), ('guts', 80), ('harvest', 81), ('healer', 82), ('heatproof', 83), ('heavymetal', 84), ('honeygather', 85), ('hugepower', 86), ('hungerswitch', 87), ('hustle', 88), ('hydration', 89), ('hypercutter', 90), ('icebody', 91), ('iceface', 92), ('icescales', 93), ('illuminate', 94), ('illusion', 95), ('immunity', 96), ('imposter', 97), ('infiltrator', 98), ('innardsout', 99), ('innerfocus', 100), ('insomnia', 101), ('intimidate', 102), ('intrepidsword', 103), ('ironbarbs', 104), ('ironfist', 105), ('justified', 106), ('keeneye', 107), ('klutz', 108), ('leafguard', 109), ('levitate', 110), ('libero', 111), ('lightmetal', 112), ('lightningrod', 113), ('limber', 114), ('liquidooze', 115), ('liquidvoice', 116), ('longreach', 117), ('magicbounce', 118), ('magicguard', 119), ('magician', 120), ('magmaarmor', 121), ('magnetpull', 122), ('marvelscale', 123), ('megalauncher', 124), ('merciless', 125), ('mimicry', 126), ('minus', 127), ('mirrorarmor', 128), ('mistysurge', 129), ('moldbreaker', 130), ('moody', 131), ('motordrive', 132), ('mountaineer', 133), ('moxie', 134), ('multiscale', 135), ('multitype', 136), ('mummy', 137), ('naturalcure', 138), ('neuroforce', 139), ('neutralizinggas', 140), ('noguard', 141), ('normalize', 142), ('oblivious', 143), ('overcoat', 144), ('overgrow', 145), ('owntempo', 146), ('parentalbond', 147), ('pastelveil', 148), ('perishbody', 149), ('persistent', 150), ('pickpocket', 151), ('pickup', 152), ('pixilate', 153), ('plus', 154), ('poisonheal', 155), ('poisonpoint', 156), ('poisontouch', 157), ('powerconstruct', 158), ('powerofalchemy', 159), ('powerspot', 160), ('prankster', 161), ('pressure', 162), ('primordialsea', 163), ('prismarmor', 164), ('propellertail', 165), ('protean', 166), ('psychicsurge', 167), ('punkrock', 168), ('purepower', 169), ('queenlymajesty', 170), ('quickdraw', 171), ('quickfeet', 172), ('raindish', 173), ('rattled', 174), ('rebound', 175), ('receiver', 176), ('reckless', 177), ('refrigerate', 178), ('regenerator', 179), ('ripen', 180), ('rivalry', 181), ('rkssystem', 182), ('rockhead', 183), ('roughskin', 184), ('runaway', 185), ('sandforce', 186), ('sandrush', 187), ('sandspit', 188), ('sandstream', 189), ('sandveil', 190), ('sapsipper', 191), ('schooling', 192), ('scrappy', 193), ('screencleaner', 194), ('serenegrace', 195), ('shadowshield', 196), ('shadowtag', 197), ('shedskin', 198), ('sheerforce', 199), ('shellarmor', 200), ('shielddust', 201), ('shieldsdown', 202), ('simple', 203), ('skilllink', 204), ('slowstart', 205), ('slushrush', 206), ('sniper', 207), ('snowcloak', 208), ('snowwarning', 209), ('solarpower', 210), ('solidrock', 211), ('soulheart', 212), ('soundproof', 213), ('speedboost', 214), ('stakeout', 215), ('stall', 216), ('stalwart', 217), ('stamina', 218), ('stancechange', 219), ('static', 220), ('steadfast', 221), ('steamengine', 222), ('steelworker', 223), ('steelyspirit', 224), ('stench', 225), ('stickyhold', 226), ('stormdrain', 227), ('strongjaw', 228), ('sturdy', 229), ('suctioncups', 230), ('superluck', 231), ('surgesurfer', 232), ('swarm', 233), ('sweetveil', 234), ('swiftswim', 235), ('symbiosis', 236), ('synchronize', 237), ('tangledfeet', 238), ('tanglinghair', 239), ('technician', 240), ('telepathy', 241), ('teravolt', 242), ('thickfat', 243), ('tintedlens', 244), ('torrent', 245), ('toughclaws', 246), ('toxicboost', 247), ('trace', 248), ('transistor', 249), ('triage', 250), ('truant', 251), ('turboblaze', 252), ('unaware', 253), ('unburden', 254), ('unnerve', 255), ('unseenfist', 256), ('victorystar', 257), ('vitalspirit', 258), ('voltabsorb', 259), ('wanderingspirit', 260), ('waterabsorb', 261), ('waterbubble', 262), ('watercompaction', 263), ('waterveil', 264), ('weakarmor', 265), ('whitesmoke', 266), ('wimpout', 267), ('wonderguard', 268), ('wonderskin', 269), ('zenmode', 270)])\n\nUnion = pickle.loads(b'\\x80\\x04\\x95\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x06typing\\x94\\x8c\\x05Union\\x94\\x93\\x94.')\nclass InvalidAction(Exception):\n    pass\n\nclass _WeatherEmbedding:\n    @staticmethod\n    def embed_weather(battle: AbstractBattle):\n        weather = battle.weather\n        weathers = np.full(len(Weather), 0, dtype=int)\n        for w, value in weather.items():\n            weathers[Weather[w.name].value - 1] = 1\n        return weathers\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Weather))]\n        high_bound = [1 for _ in range(len(Weather))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _MoveStatusEmbedding:\n    @staticmethod\n    def embed_move_status(move: Move):\n        if move is None:\n            status = np.full(len(Status), -1, dtype=int)\n            chance = np.full(len(Status), -1, dtype=np.float64)\n        else:\n            status = np.full(len(Status), 0, dtype=int)\n            chance = np.full(len(Status), 0, dtype=np.float64)\n            if move.status is not None:\n                status[Status[move.status.name].value - 1] = 1\n                chance[Status[move.status.name].value - 1] = 1.0\n            else:\n                secondary = move.secondary\n                for d in secondary:\n                    if \"status\" in d.keys():\n                        secondary_chance = d[\"chance\"] / 100\n                        secondary_status = getattr(Status, d[\"status\"].upper())\n                        status[secondary_status.value - 1] = 1\n                        chance[secondary_status.value - 1] = secondary_chance\n        return {\"status\": status, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        status_low_bound = [-1 for _ in range(len(Status))]\n        status_high_bound = [1 for _ in range(len(Status))]\n        status_space = Box(\n            low=np.array(status_low_bound, dtype=int),\n            high=np.array(status_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(len(Status))]\n        chance_high_bound = [1.0 for _ in range(len(Status))]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"status\": status_space, \"chances\": chance_space})\n\nclass _MoveCategoryEmbedding:\n    @staticmethod\n    def embed_category(move: Move):\n        if move is None:\n            return np.full(len(MoveCategory), -1, dtype=int)\n        category = np.full(len(MoveCategory), 0, dtype=int)\n        category[MoveCategory[move.category.name].value - 1] = 1\n        return category\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(MoveCategory))]\n        high_bound = [1 for _ in range(len(MoveCategory))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _PokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nclass _EnemyPokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            moves = list(mon.moves.values())\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nObservationType = pickle.loads(b'\\x80\\x04\\x952\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x1apoke_env.player.openai_api\\x94\\x8c\\x0fObservationType\\x94\\x93\\x94.')\nclass _ItemEmbedding:\n    @staticmethod\n    def embed_item(mon: Pokemon):\n        if mon is None or not mon.item or mon.item == UNKNOWN_ITEM:\n            return np.full(len(ITEMS), -1, dtype=int)\n        battle_item = mon.item\n        items = np.full(len(ITEMS), 0, dtype=int)\n        items[getattr(ITEMS, battle_item).value - 1] = 1\n        return items\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ITEMS))]\n        high_bound = [1 for _ in range(len(ITEMS))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nSTATS = {'hp': 0, 'atk': 1, 'def': 2, 'spa': 3, 'spd': 4, 'spe': 5, 'accuracy': 6, 'evasion': 7}\n\npoke_env.environment.side_condition.SideCondition = enum.Enum(value='SideCondition', module='poke_env.environment.side_condition', names=[('_UNKNOWN', 1), ('AURORA_VEIL', 2), ('FIRE_PLEDGE', 3), ('G_MAX_CANNONADE', 4), ('G_MAX_STEELSURGE', 5), ('G_MAX_VINE_LASH', 6), ('G_MAX_VOLCALITH', 7), ('G_MAX_WILDFIRE', 8), ('GRASS_PLEDGE', 9), ('LIGHT_SCREEN', 10), ('LUCKY_CHANT', 11), ('MIST', 12), ('REFLECT', 13), ('SAFEGUARD', 14), ('SPIKES', 15), ('STEALTH_ROCK', 16), ('STICKY_WEB', 17), ('TAILWIND', 18), ('TOXIC_SPIKES', 19), ('WATER_PLEDGE', 20)])\n\nclass _FieldEmbedding:\n    @staticmethod\n    def embed_field(battle: AbstractBattle):\n        fields = np.full(len(Field), 0, dtype=int)\n        battle_fields = battle.fields\n        for field, value in battle_fields.items():\n            fields[Field[field.name].value - 1] = 1\n        return fields\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(Field))]\n        high_bound = [1 for _ in range(len(Field))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nSideCondition = enum.Enum(value='SideCondition', names=[('_UNKNOWN', 1), ('AURORA_VEIL', 2), ('FIRE_PLEDGE', 3), ('G_MAX_CANNONADE', 4), ('G_MAX_STEELSURGE', 5), ('G_MAX_VINE_LASH', 6), ('G_MAX_VOLCALITH', 7), ('G_MAX_WILDFIRE', 8), ('GRASS_PLEDGE', 9), ('LIGHT_SCREEN', 10), ('LUCKY_CHANT', 11), ('MIST', 12), ('REFLECT', 13), ('SAFEGUARD', 14), ('SPIKES', 15), ('STEALTH_ROCK', 16), ('STICKY_WEB', 17), ('TAILWIND', 18), ('TOXIC_SPIKES', 19), ('WATER_PLEDGE', 20)])\n\nMoveCategory = enum.Enum(value='MoveCategory', names=[('PHYSICAL', 1), ('SPECIAL', 2), ('STATUS', 3)])\n\nclass _EffectsEmbedding:\n    @staticmethod\n    def embed_effects(mon: Pokemon):\n        battle_effects = {}\n        if mon is not None:\n            battle_effects = mon.effects\n        effects = np.full(len(Effect), -1, dtype=int)\n        for effect, counter in battle_effects.items():\n            effects[Effect[effect.name].value - 1] = counter\n        return effects\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(Effect))]\n        high_bound = [6 for _ in range(len(Effect))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nStatus = enum.Enum(value='Status', names=[('BRN', 1), ('FNT', 2), ('FRZ', 3), ('PAR', 4), ('PSN', 5), ('SLP', 6), ('TOX', 7)])\n\nclass _MoveFlagsEmbedding:\n    @staticmethod\n    def embed_move_flags(move: Move, opponent: Pokemon):\n        if move is None:\n            return np.full(6, -1, dtype=int)\n        flags = np.full(6, 0, dtype=int)\n        if move.can_z_move:\n            flags[0] = 1\n        if move.thaws_target:\n            flags[1] = 1\n        if move.stalling_move:\n            flags[2] = 1\n        if move.ignore_immunity and opponent is not None:\n            if isinstance(move.ignore_immunity, bool):\n                flags[3] = 1\n            else:\n                for t in opponent.types:\n                    if t in move.ignore_immunity:\n                        flags[3] = 1\n        if move.force_switch:\n            flags[4] = 1\n        if move.breaks_protect:\n            flags[5] = 1\n        return flags\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(6)]\n        high_bound = [1 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nSTACKABLE_CONDITIONS = {poke_env.environment.side_condition.SideCondition.SPIKES: 3, poke_env.environment.side_condition.SideCondition.TOXIC_SPIKES: 2}\n\nPokemonType = enum.Enum(value='PokemonType', names=[('BUG', 1), ('DARK', 2), ('DRAGON', 3), ('ELECTRIC', 4), ('FAIRY', 5), ('FIGHTING', 6), ('FIRE', 7), ('FLYING', 8), ('GHOST', 9), ('GRASS', 10), ('GROUND', 11), ('ICE', 12), ('NORMAL', 13), ('POISON', 14), ('PSYCHIC', 15), ('ROCK', 16), ('STEEL', 17), ('WATER', 18)])\n\nclass _MoveEmbedding:\n    @staticmethod\n    def embed_move(move: Move, mon: Pokemon, opponent: Pokemon):\n        if move is None:\n            base_power = -1.0\n            accuracy = -1.0\n            pps = -1.0\n            drain = -1.0\n            heal = -1.0\n            recoil = -1.0\n            damage_multiplier = -1.0\n            min_hits = -1\n            max_hits = -1\n            mean_hits = -1.0\n            crit_ratio = -1\n            priority = -8\n            damage = -1\n        else:\n            base_power = move.base_power / 100\n            accuracy = move.accuracy\n            pps = move.current_pp / move.max_pp\n            drain = move.drain\n            heal = move.heal\n            recoil = move.recoil\n            if opponent is not None:\n                damage_multiplier = opponent.damage_multiplier(move)\n            else:\n                damage_multiplier = -1.0\n            min_hits, max_hits = move.n_hit\n            mean_hits = move.expected_hits\n            crit_ratio = move.crit_ratio\n            priority = move.priority\n            damage = move.damage\n            if damage == \"level\":\n                damage = mon.level\n        float_move_info = np.array(\n            [\n                base_power,\n                accuracy,\n                pps,\n                drain,\n                heal,\n                mean_hits,\n                recoil,\n                damage_multiplier,\n            ],\n            dtype=np.float64,\n        )\n        int_move_info = np.array(\n            [min_hits, max_hits, crit_ratio, priority, damage], dtype=int\n        )\n        return {\n            \"float_move_info\": float_move_info,\n            \"int_move_info\": int_move_info,\n            \"move_category\": _MoveCategoryEmbedding.embed_category(move),\n            \"move_type\": _TypeEmbedding.embed_type(move),\n            \"move_flags\": _MoveFlagsEmbedding.embed_move_flags(move, opponent),\n            \"move_status\": _MoveStatusEmbedding.embed_move_status(move),\n            \"boosts\": _BoostsEmbedding.embed_boosts(move),\n            \"self_boosts\": _SelfBoostsEmbedding.embed_self_boosts(move),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        float_info_low_bound = [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]\n        float_info_high_bound = [4.0, 1.0, 1.0, 1.0, 1.0, 5.23, 1.0, 4.0]\n        #                                                 ^^^^\n        # 5.23 is the expected hit number for triple kick and triple axel\n        #\n        float_info_space = Box(\n            low=np.array(float_info_low_bound, dtype=np.float64),\n            high=np.array(float_info_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        int_info_low_bound = [-1, -1, -1, -8, -1]\n        int_info_high_bound = [5, 5, 6, 5, 100]\n        int_info_space = Box(\n            low=np.array(int_info_low_bound, dtype=int),\n            high=np.array(int_info_high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict(\n            {\n                \"float_move_info\": float_info_space,\n                \"int_move_info\": int_info_space,\n                \"move_category\": _MoveCategoryEmbedding.get_embedding(),\n                \"move_type\": _TypeEmbedding.get_embedding(),\n                \"move_flags\": _MoveFlagsEmbedding.get_embedding(),\n                \"move_status\": _MoveStatusEmbedding.get_embedding(),\n                \"boosts\": _BoostsEmbedding.get_embedding(),\n                \"self_boosts\": _SelfBoostsEmbedding.get_embedding(),\n            }\n        )\n\nEffect = enum.Enum(value='Effect', names=[('_UNKNOWN', 1), ('AFTER_YOU', 2), ('AFTERMATH', 3), ('AQUA_RING', 4), ('AROMATHERAPY', 5), ('AROMA_VEIL', 6), ('ATTRACT', 7), ('AUTOTOMIZE', 8), ('BAD_DREAMS', 9), ('BANEFUL_BUNKER', 10), ('BATTLE_BOND', 11), ('BIDE', 12), ('BIND', 13), ('BURN_UP', 14), ('CELEBRATE', 15), ('CHARGE', 16), ('CLAMP', 17), ('CONFUSION', 18), ('COURT_CHANGE', 19), ('CRAFTY_SHIELD', 20), ('CURSE', 21), ('CUSTAP_BERRY', 22), ('DANCER', 23), ('DESTINY_BOND', 24), ('DISABLE', 25), ('DISGUISE', 26), ('DOOM_DESIRE', 27), ('DYNAMAX', 28), ('EERIE_SPELL', 29), ('ELECTRIC_TERRAIN', 30), ('EMBARGO', 31), ('EMERGENCY_EXIT', 32), ('ENCORE', 33), ('ENDURE', 34), ('FAIRY_LOCK', 35), ('FEINT', 36), ('FIRE_SPIN', 37), ('FLASH_FIRE', 38), ('FLOWER_VEIL', 39), ('FOCUS_BAND', 40), ('FOCUS_ENERGY', 41), ('FORESIGHT', 42), ('FOREWARN', 43), ('FUTURE_SIGHT', 44), ('G_MAX_CENTIFERNO', 45), ('G_MAX_CHI_STRIKE', 46), ('G_MAX_ONE_BLOW', 47), ('G_MAX_RAPID_FLOW', 48), ('G_MAX_SANDBLAST', 49), ('GRAVITY', 50), ('GRUDGE', 51), ('GUARD_SPLIT', 52), ('GULP_MISSILE', 53), ('HEAL_BELL', 54), ('HEAL_BLOCK', 55), ('HEALER', 56), ('HYDRATION', 57), ('HYPERSPACE_FURY', 58), ('HYPERSPACE_HOLE', 59), ('ICE_FACE', 60), ('ILLUSION', 61), ('IMMUNITY', 62), ('IMPRISON', 63), ('INFESTATION', 64), ('INGRAIN', 65), ('INNARDS_OUT', 66), ('INSOMNIA', 67), ('IRON_BARBS', 68), ('LASER_FOCUS', 69), ('LEECH_SEED', 70), ('LIGHTNING_ROD', 71), ('LIMBER', 72), ('LIQUID_OOZE', 73), ('LOCK_ON', 74), ('MAGMA_STORM', 75), ('MAGNET_RISE', 76), ('MAGNITUDE', 77), ('MAT_BLOCK', 78), ('MAX_GUARD', 79), ('MIMIC', 80), ('MIMICRY', 81), ('MIND_READER', 82), ('MINIMIZE', 83), ('MIRACLE_EYE', 84), ('MIST', 85), ('MISTY_TERRAIN', 86), ('MUMMY', 87), ('NEUTRALIZING_GAS', 88), ('NIGHTMARE', 89), ('NO_RETREAT', 90), ('OBLIVIOUS', 91), ('OCTOLOCK', 92), ('OWN_TEMPO', 93), ('PASTEL_VEIL', 94), ('PERISH0', 95), ('PERISH1', 96), ('PERISH2', 97), ('PERISH3', 98), ('PHANTOM_FORCE', 99), ('POLTERGEIST', 100), ('POWDER', 101), ('POWER_CONSTRUCT', 102), ('POWER_SPLIT', 103), ('POWER_TRICK', 104), ('PROTECT', 105), ('PROTECTIVE_PADS', 106), ('PSYCHIC_TERRAIN', 107), ('PURSUIT', 108), ('QUASH', 109), ('QUICK_CLAW', 110), ('QUICK_GUARD', 111), ('REFLECT', 112), ('RIPEN', 113), ('ROUGH_SKIN', 114), ('SAFEGUARD', 115), ('SAFETY_GOGGLES', 116), ('SAND_TOMB', 117), ('SCREEN_CLEANER', 118), ('SHADOW_FORCE', 119), ('SHED_SKIN', 120), ('SKETCH', 121), ('SKILL_SWAP', 122), ('SKY_DROP', 123), ('SLOW_START', 124), ('SMACK_DOWN', 125), ('SNAP_TRAP', 126), ('SNATCH', 127), ('SPEED_SWAP', 128), ('SPITE', 129), ('STICKY_HOLD', 130), ('STICKY_WEB', 131), ('STOCKPILE', 132), ('STOCKPILE1', 133), ('STOCKPILE2', 134), ('STOCKPILE3', 135), ('STORM_DRAIN', 136), ('STRUGGLE', 137), ('SUBSTITUTE', 138), ('SUCTION_CUPS', 139), ('SWEET_VEIL', 140), ('SYMBIOSIS', 141), ('SYNCHRONIZE', 142), ('TAR_SHOT', 143), ('TAUNT', 144), ('TELEKINESIS', 145), ('TELEPATHY', 146), ('THROAT_CHOP', 147), ('THUNDER_CAGE', 148), ('TORMENT', 149), ('TRAPPED', 150), ('TRICK', 151), ('TYPEADD', 152), ('TYPECHANGE', 153), ('TYPE_CHANGE', 154), ('UPROAR', 155), ('VITAL_SPIRIT', 156), ('WANDERING_SPIRIT', 157), ('WATER_BUBBLE', 158), ('WATER_VEIL', 159), ('WHIRLPOOL', 160), ('WIDE_GUARD', 161), ('WIMP_OUT', 162), ('WRAP', 163), ('YAWN', 164)])\n\nclass _EnemyActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        moves = []\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n            moves = list(mon.moves.values())\n            for move in moves:\n                if isinstance(move, DynamaxMove) != mon.is_dynamaxed:\n                    moves.remove(move)\n        while len(moves) < 4:\n            moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"move_1\": _MoveEmbedding.embed_move(moves[0], mon, battle.active_pokemon),\n            \"move_2\": _MoveEmbedding.embed_move(moves[1], mon, battle.active_pokemon),\n            \"move_3\": _MoveEmbedding.embed_move(moves[2], mon, battle.active_pokemon),\n            \"move_4\": _MoveEmbedding.embed_move(moves[3], mon, battle.active_pokemon),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nField = enum.Enum(value='Field', names=[('_UNKNOWN', 1), ('ELECTRIC_TERRAIN', 2), ('GRASSY_TERRAIN', 3), ('GRAVITY', 4), ('HEAL_BLOCK', 5), ('MAGIC_ROOM', 6), ('MISTY_TERRAIN', 7), ('MUD_SPORT', 8), ('MUD_SPOT', 9), ('PSYCHIC_TERRAIN', 10), ('TRICK_ROOM', 11), ('WATER_SPORT', 12), ('WONDER_ROOM', 13)])\n\nclass _BaseStatsEmbedding:\n    @staticmethod\n    def embed_stats(mon: Pokemon):\n        if mon is None:\n            return np.full(6, -1.0, dtype=np.float64)\n        stats = np.full(6, 0.0, dtype=np.float64)\n        stats[0] = mon.base_stats[\"hp\"] / 255\n        stats[1] = mon.base_stats[\"atk\"] / 255\n        stats[2] = mon.base_stats[\"def\"] / 255\n        stats[3] = mon.base_stats[\"spa\"] / 255\n        stats[4] = mon.base_stats[\"spd\"] / 255\n        stats[5] = mon.base_stats[\"spe\"] / 255\n        return stats\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1.0 for _ in range(6)]\n        high_bound = [1.0 for _ in range(6)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n\nclass _MonBoostsEmbedding:\n    @staticmethod\n    def embed_boosts(mon: Pokemon):\n        if mon is None:\n            return np.full(len(STATS) - 1, -1.0, dtype=np.float64)\n        boosts = np.full(len(STATS) - 1, 1.0, dtype=np.float64)\n        mon_boosts = mon.boosts\n        for boost, boost_value in mon_boosts.items():\n            stat_index = STATS[boost] - 1\n            boost_multiplier = BOOSTS_MULTIPLIERS[boost_value + 6]\n            boosts[stat_index] = boost_multiplier\n        return boosts\n\n    @staticmethod\n    def get_embedding():\n        low_bound = [-1.0 for _ in range(len(STATS) - 1)]\n        high_bound = [4.0 for _ in range(len(STATS) - 1)]\n        return Box(\n            low=np.array(low_bound, dtype=np.float64),\n            high=np.array(high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n\nITEMS = enum.Enum(value='ITEMS', names=[('abomasite', 1), ('absolite', 2), ('absorbbulb', 3), ('adamantorb', 4), ('adrenalineorb', 5), ('aerodactylite', 6), ('aggronite', 7), ('aguavberry', 8), ('airballoon', 9), ('alakazite', 10), ('aloraichiumz', 11), ('altarianite', 12), ('ampharosite', 13), ('apicotberry', 14), ('armorfossil', 15), ('aspearberry', 16), ('assaultvest', 17), ('audinite', 18), ('babiriberry', 19), ('banettite', 20), ('beastball', 21), ('beedrillite', 22), ('belueberry', 23), ('berry', 24), ('berryjuice', 25), ('berrysweet', 26), ('berserkgene', 27), ('bigroot', 28), ('bindingband', 29), ('bitterberry', 30), ('blackbelt', 31), ('blackglasses', 32), ('blacksludge', 33), ('blastoisinite', 34), ('blazikenite', 35), ('blueorb', 36), ('blukberry', 37), ('blunderpolicy', 38), ('bottlecap', 39), ('brightpowder', 40), ('buggem', 41), ('buginiumz', 42), ('bugmemory', 43), ('burndrive', 44), ('burntberry', 45), ('cameruptite', 46), ('cellbattery', 47), ('charcoal', 48), ('charizarditex', 49), ('charizarditey', 50), ('chartiberry', 51), ('cheriberry', 52), ('cherishball', 53), ('chestoberry', 54), ('chilanberry', 55), ('chilldrive', 56), ('chippedpot', 57), ('choiceband', 58), ('choicescarf', 59), ('choicespecs', 60), ('chopleberry', 61), ('clawfossil', 62), ('cloversweet', 63), ('cobaberry', 64), ('colburberry', 65), ('cornnberry', 66), ('coverfossil', 67), ('crackedpot', 68), ('crucibellite', 69), ('custapberry', 70), ('damprock', 71), ('darkgem', 72), ('darkiniumz', 73), ('darkmemory', 74), ('dawnstone', 75), ('decidiumz', 76), ('deepseascale', 77), ('deepseatooth', 78), ('destinyknot', 79), ('diancite', 80), ('diveball', 81), ('domefossil', 82), ('dousedrive', 83), ('dracoplate', 84), ('dragonfang', 85), ('dragongem', 86), ('dragoniumz', 87), ('dragonmemory', 88), ('dragonscale', 89), ('dreadplate', 90), ('dreamball', 91), ('dubiousdisc', 92), ('durinberry', 93), ('duskball', 94), ('duskstone', 95), ('earthplate', 96), ('eeviumz', 97), ('ejectbutton', 98), ('ejectpack', 99), ('electirizer', 100), ('electricgem', 101), ('electricmemory', 102), ('electricseed', 103), ('electriumz', 104), ('energypowder', 105), ('enigmaberry', 106), ('eviolite', 107), ('expertbelt', 108), ('fairiumz', 109), ('fairygem', 110), ('fairymemory', 111), ('fastball', 112), ('fightinggem', 113), ('fightingmemory', 114), ('fightiniumz', 115), ('figyberry', 116), ('firegem', 117), ('firememory', 118), ('firestone', 119), ('firiumz', 120), ('fistplate', 121), ('flameorb', 122), ('flameplate', 123), ('floatstone', 124), ('flowersweet', 125), ('flyinggem', 126), ('flyingmemory', 127), ('flyiniumz', 128), ('focusband', 129), ('focussash', 130), ('fossilizedbird', 131), ('fossilizeddino', 132), ('fossilizeddrake', 133), ('fossilizedfish', 134), ('friendball', 135), ('fullincense', 136), ('galladite', 137), ('ganlonberry', 138), ('garchompite', 139), ('gardevoirite', 140), ('gengarite', 141), ('ghostgem', 142), ('ghostiumz', 143), ('ghostmemory', 144), ('glalitite', 145), ('goldberry', 146), ('goldbottlecap', 147), ('grassgem', 148), ('grassiumz', 149), ('grassmemory', 150), ('grassyseed', 151), ('greatball', 152), ('grepaberry', 153), ('gripclaw', 154), ('griseousorb', 155), ('groundgem', 156), ('groundiumz', 157), ('groundmemory', 158), ('gyaradosite', 159), ('habanberry', 160), ('hardstone', 161), ('healball', 162), ('heatrock', 163), ('heavyball', 164), ('heavydutyboots', 165), ('helixfossil', 166), ('heracronite', 167), ('hondewberry', 168), ('houndoominite', 169), ('iapapaberry', 170), ('iceberry', 171), ('icegem', 172), ('icememory', 173), ('icestone', 174), ('icicleplate', 175), ('iciumz', 176), ('icyrock', 177), ('inciniumz', 178), ('insectplate', 179), ('ironball', 180), ('ironplate', 181), ('jabocaberry', 182), ('jawfossil', 183), ('kangaskhanite', 184), ('kasibberry', 185), ('kebiaberry', 186), ('keeberry', 187), ('kelpsyberry', 188), ('kingsrock', 189), ('kommoniumz', 190), ('laggingtail', 191), ('lansatberry', 192), ('latiasite', 193), ('latiosite', 194), ('laxincense', 195), ('leafstone', 196), ('leek', 197), ('leftovers', 198), ('leppaberry', 199), ('levelball', 200), ('liechiberry', 201), ('lifeorb', 202), ('lightball', 203), ('lightclay', 204), ('lopunnite', 205), ('loveball', 206), ('lovesweet', 207), ('lucarionite', 208), ('luckypunch', 209), ('lumberry', 210), ('luminousmoss', 211), ('lunaliumz', 212), ('lureball', 213), ('lustrousorb', 214), ('luxuryball', 215), ('lycaniumz', 216), ('machobrace', 217), ('magmarizer', 218), ('magnet', 219), ('magoberry', 220), ('magostberry', 221), ('mail', 222), ('manectite', 223), ('marangaberry', 224), ('marshadiumz', 225), ('masterball', 226), ('mawilite', 227), ('meadowplate', 228), ('medichamite', 229), ('mentalherb', 230), ('metagrossite', 231), ('metalcoat', 232), ('metalpowder', 233), ('metronome', 234), ('mewniumz', 235), ('mewtwonitex', 236), ('mewtwonitey', 237), ('micleberry', 238), ('mimikiumz', 239), ('mindplate', 240), ('mintberry', 241), ('miracleberry', 242), ('miracleseed', 243), ('mistyseed', 244), ('moonball', 245), ('moonstone', 246), ('muscleband', 247), ('mysteryberry', 248), ('mysticwater', 249), ('nanabberry', 250), ('nestball', 251), ('netball', 252), ('nevermeltice', 253), ('nomelberry', 254), ('normalgem', 255), ('normaliumz', 256), ('occaberry', 257), ('oddincense', 258), ('oldamber', 259), ('oranberry', 260), ('ovalstone', 261), ('pamtreberry', 262), ('parkball', 263), ('passhoberry', 264), ('payapaberry', 265), ('pechaberry', 266), ('persimberry', 267), ('petayaberry', 268), ('pidgeotite', 269), ('pikaniumz', 270), ('pikashuniumz', 271), ('pinapberry', 272), ('pinkbow', 273), ('pinsirite', 274), ('pixieplate', 275), ('plumefossil', 276), ('poisonbarb', 277), ('poisongem', 278), ('poisoniumz', 279), ('poisonmemory', 280), ('pokeball', 281), ('polkadotbow', 282), ('pomegberry', 283), ('poweranklet', 284), ('powerband', 285), ('powerbelt', 286), ('powerbracer', 287), ('powerherb', 288), ('powerlens', 289), ('powerweight', 290), ('premierball', 291), ('primariumz', 292), ('prismscale', 293), ('protectivepads', 294), ('protector', 295), ('przcureberry', 296), ('psncureberry', 297), ('psychicgem', 298), ('psychicmemory', 299), ('psychicseed', 300), ('psychiumz', 301), ('qualotberry', 302), ('quickball', 303), ('quickclaw', 304), ('quickpowder', 305), ('rabutaberry', 306), ('rarebone', 307), ('rawstberry', 308), ('razorclaw', 309), ('razorfang', 310), ('razzberry', 311), ('reapercloth', 312), ('redcard', 313), ('redorb', 314), ('repeatball', 315), ('ribbonsweet', 316), ('rindoberry', 317), ('ringtarget', 318), ('rockgem', 319), ('rockincense', 320), ('rockiumz', 321), ('rockmemory', 322), ('rockyhelmet', 323), ('roomservice', 324), ('rootfossil', 325), ('roseincense', 326), ('roseliberry', 327), ('rowapberry', 328), ('rustedshield', 329), ('rustedsword', 330), ('sablenite', 331), ('sachet', 332), ('safariball', 333), ('safetygoggles', 334), ('sailfossil', 335), ('salacberry', 336), ('salamencite', 337), ('sceptilite', 338), ('scizorite', 339), ('scopelens', 340), ('seaincense', 341), ('sharpbeak', 342), ('sharpedonite', 343), ('shedshell', 344), ('shellbell', 345), ('shinystone', 346), ('shockdrive', 347), ('shucaberry', 348), ('silkscarf', 349), ('silverpowder', 350), ('sitrusberry', 351), ('skullfossil', 352), ('skyplate', 353), ('slowbronite', 354), ('smoothrock', 355), ('snorliumz', 356), ('snowball', 357), ('softsand', 358), ('solganiumz', 359), ('souldew', 360), ('spelltag', 361), ('spelonberry', 362), ('splashplate', 363), ('spookyplate', 364), ('sportball', 365), ('starfberry', 366), ('starsweet', 367), ('steelgem', 368), ('steeliumz', 369), ('steelixite', 370), ('steelmemory', 371), ('stick', 372), ('stickybarb', 373), ('stoneplate', 374), ('strawberrysweet', 375), ('sunstone', 376), ('swampertite', 377), ('sweetapple', 378), ('tamatoberry', 379), ('tangaberry', 380), ('tapuniumz', 381), ('tartapple', 382), ('terrainextender', 383), ('thickclub', 384), ('throatspray', 385), ('thunderstone', 386), ('timerball', 387), ('toxicorb', 388), ('toxicplate', 389), ('tr00', 390), ('tr01', 391), ('tr02', 392), ('tr03', 393), ('tr04', 394), ('tr05', 395), ('tr06', 396), ('tr07', 397), ('tr08', 398), ('tr09', 399), ('tr10', 400), ('tr11', 401), ('tr12', 402), ('tr13', 403), ('tr14', 404), ('tr15', 405), ('tr16', 406), ('tr17', 407), ('tr18', 408), ('tr19', 409), ('tr20', 410), ('tr21', 411), ('tr22', 412), ('tr23', 413), ('tr24', 414), ('tr25', 415), ('tr26', 416), ('tr27', 417), ('tr28', 418), ('tr29', 419), ('tr30', 420), ('tr31', 421), ('tr32', 422), ('tr33', 423), ('tr34', 424), ('tr35', 425), ('tr36', 426), ('tr37', 427), ('tr38', 428), ('tr39', 429), ('tr40', 430), ('tr41', 431), ('tr42', 432), ('tr43', 433), ('tr44', 434), ('tr45', 435), ('tr46', 436), ('tr47', 437), ('tr48', 438), ('tr49', 439), ('tr50', 440), ('tr51', 441), ('tr52', 442), ('tr53', 443), ('tr54', 444), ('tr55', 445), ('tr56', 446), ('tr57', 447), ('tr58', 448), ('tr59', 449), ('tr60', 450), ('tr61', 451), ('tr62', 452), ('tr63', 453), ('tr64', 454), ('tr65', 455), ('tr66', 456), ('tr67', 457), ('tr68', 458), ('tr69', 459), ('tr70', 460), ('tr71', 461), ('tr72', 462), ('tr73', 463), ('tr74', 464), ('tr75', 465), ('tr76', 466), ('tr77', 467), ('tr78', 468), ('tr79', 469), ('tr80', 470), ('tr81', 471), ('tr82', 472), ('tr83', 473), ('tr84', 474), ('tr85', 475), ('tr86', 476), ('tr87', 477), ('tr88', 478), ('tr89', 479), ('tr90', 480), ('tr91', 481), ('tr92', 482), ('tr93', 483), ('tr94', 484), ('tr95', 485), ('tr96', 486), ('tr97', 487), ('tr98', 488), ('tr99', 489), ('twistedspoon', 490), ('tyranitarite', 491), ('ultraball', 492), ('ultranecroziumz', 493), ('upgrade', 494), ('utilityumbrella', 495), ('venusaurite', 496), ('wacanberry', 497), ('watergem', 498), ('wateriumz', 499), ('watermemory', 500), ('waterstone', 501), ('watmelberry', 502), ('waveincense', 503), ('weaknesspolicy', 504), ('wepearberry', 505), ('whippeddream', 506), ('whiteherb', 507), ('widelens', 508), ('wikiberry', 509), ('wiseglasses', 510), ('yacheberry', 511), ('zapplate', 512), ('zoomlens', 513)])\n\nUNKNOWN_ITEM = 'unknown_item'\n\nclass _SideConditionEmbedding:\n    @staticmethod\n    def embed_side_conditions(battle: AbstractBattle):\n        battle_side_conditions = battle.side_conditions\n        opponent_battle_side_conditions = battle.opponent_side_conditions\n        side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        opponent_side_conditions = np.full(len(SideCondition), 0, dtype=int)\n        for condition, value in battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                side_conditions[SideCondition[condition.name].value - 1] = value\n            else:\n                side_conditions[SideCondition[condition.name].value - 1] = 1\n        for condition, value in opponent_battle_side_conditions.items():\n            if condition in STACKABLE_CONDITIONS.keys():\n                opponent_side_conditions[\n                    SideCondition[condition.name].value - 1\n                ] = value\n            else:\n                opponent_side_conditions[SideCondition[condition.name].value - 1] = 1\n        return {\n            \"player_conditions\": side_conditions,\n            \"opponent_conditions\": opponent_side_conditions,\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [0 for _ in range(len(SideCondition))]\n        high_bound = [1 for _ in range(len(SideCondition))]\n        for condition in STACKABLE_CONDITIONS.keys():\n            low_bound[SideCondition[condition.name].value - 1] = 0\n            high_bound[SideCondition[condition.name].value - 1] = STACKABLE_CONDITIONS[\n                condition\n            ]\n        bound_box = Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n        return Dict({\"player_conditions\": bound_box, \"opponent_conditions\": bound_box})\n\nclass _AbilityEmbedding:\n    @staticmethod\n    def embed_ability(mon: Pokemon):\n        if mon is None:\n            return np.full(len(ABILITIES), -1, dtype=int)\n        battle_abilities = np.full(len(ABILITIES), 0, dtype=int)\n        if not mon.ability:\n            possible_abilities = mon.possible_abilities\n            if len(possible_abilities) == 1:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 2\n            else:\n                for ability in possible_abilities:\n                    battle_abilities[getattr(ABILITIES, ability).value - 1] = 1\n            return battle_abilities\n        battle_abilities[getattr(ABILITIES, mon.ability).value - 1] = 2\n        return battle_abilities\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(ABILITIES))]\n        high_bound = [2 for _ in range(len(ABILITIES))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nclass _BoostsEmbedding:\n    @staticmethod\n    def embed_boosts(move: Move):\n        if move is None:\n            boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            move_boosts = {}\n            if move.target != \"self\" and move.boosts is not None:\n                move_boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"boosts\" in d.keys():\n                    secondary_chance = d[\"chance\"] / 100\n                    for key, value in d[\"boosts\"].items():\n                        secondary_boosts[key] = (value, secondary_chance)\n            for key, value in move_boosts.items():\n                boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        boosts_low_bound = [-7 for _ in range(7)]\n        boosts_high_bound = [6 for _ in range(7)]\n        boosts_space = Box(\n            low=np.array(boosts_low_bound, dtype=int),\n            high=np.array(boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": boosts_space, \"chances\": chance_space})\n\nclass _TypeEmbedding:\n    @staticmethod\n    def embed_type(mon_or_move: Union[Pokemon, Move]):\n        if mon_or_move is None:\n            return np.full(len(PokemonType), -1, dtype=int)\n        types = np.full(len(PokemonType), 0, dtype=int)\n        if isinstance(mon_or_move, Move):\n            battle_types = [mon_or_move.type]\n        elif isinstance(mon_or_move, Pokemon):\n            battle_types = mon_or_move.types\n        else:\n            raise RuntimeError(f\"Expected Move or Pokemon, got {type(mon_or_move)}.\")\n        for mon_type in battle_types:\n            if mon_type is not None:\n                types[PokemonType[mon_type.name].value - 1] = 1\n        return types\n\n    @staticmethod\n    def get_embedding() -> Space:\n        low_bound = [-1 for _ in range(len(PokemonType))]\n        high_bound = [1 for _ in range(len(PokemonType))]\n        return Box(\n            low=np.array(low_bound, dtype=int),\n            high=np.array(high_bound, dtype=int),\n            dtype=int,\n        )\n\nBOOSTS_MULTIPLIERS = [0.25, 0.28, 0.33, 0.4, 0.5, 0.66, 1, 1.5, 2, 2.5, 3, 3.5, 4]\n\nclass _BattlefieldEmbedding:\n    @staticmethod\n    def embed_battlefield(battle: AbstractBattle):\n        dynamax_turns = np.full(2, -1, dtype=int)\n        if battle.dynamax_turns_left is not None:\n            dynamax_turns[0] = battle.dynamax_turns_left\n        if battle.opponent_dynamax_turns_left is not None:\n            dynamax_turns[1] = battle.opponent_dynamax_turns_left\n\n        boolean_flags = np.full(6, 0, dtype=int)\n        if battle.can_mega_evolve:\n            boolean_flags[0] = 1\n        if battle.can_z_move:\n            boolean_flags[1] = 1\n        if battle.can_dynamax:\n            boolean_flags[2] = 1\n        if battle.opponent_can_dynamax:\n            boolean_flags[3] = 1\n        if battle.maybe_trapped:\n            boolean_flags[4] = 1\n        try:\n            forced_switch = any(battle.force_switch)\n        except TypeError:\n            forced_switch = battle.force_switch\n        if forced_switch:\n            boolean_flags[5] = 1\n\n        return {\n            \"dynamax_turns\": dynamax_turns,\n            \"boolean_flags\": boolean_flags,\n            \"fields\": _FieldEmbedding.embed_field(battle),\n            \"side_conditions\": _SideConditionEmbedding.embed_side_conditions(battle),\n            \"weather\": _WeatherEmbedding.embed_weather(battle),\n        }\n\n    @staticmethod\n    def get_embedding():\n        dynamax_turns_low = [-1, -1]\n        dynamax_turns_high = [3, 3]\n        dynamax_turns = Box(\n            low=np.array(dynamax_turns_low, dtype=int),\n            high=np.array(dynamax_turns_high, dtype=int),\n            dtype=int,\n        )\n        boolean_flags = Box(low=0, high=1, shape=(6,), dtype=int)\n        return Dict(\n            {\n                \"dynamax_turns\": dynamax_turns,\n                \"boolean_flags\": boolean_flags,\n                \"fields\": _FieldEmbedding.get_embedding(),\n                \"side_conditions\": _SideConditionEmbedding.get_embedding(),\n                \"weather\": _WeatherEmbedding.get_embedding(),\n            }\n        )\n\nclass _ActivePokemonEmbedding:\n    @staticmethod\n    def embed_pokemon(mon: Pokemon, battle: AbstractBattle):\n        current_hp_fraction = np.full(1, -1.0, dtype=np.float64)\n        protect_counter = np.full(1, 0, dtype=int)\n        if mon is not None:\n            current_hp_fraction[0] = mon.current_hp_fraction\n            protect_counter[0] = mon.protect_counter\n        available_moves = battle.available_moves[:]\n        if (\n            len(available_moves) > 0\n            and isinstance(available_moves[0], DynamaxMove) != mon.is_dynamaxed\n        ):\n            if isinstance(available_moves[0], DynamaxMove) and not mon.is_dynamaxed:\n                available_moves = [\n                    m._parent for m in available_moves  # noqa: used for bug in poke_env\n                ]\n            elif not isinstance(available_moves[0], DynamaxMove) and mon.is_dynamaxed:\n                available_moves = [m.dynamaxed for m in available_moves]\n        while len(available_moves) < 4:\n            available_moves.append(None)\n        return {\n            \"current_hp_fraction\": current_hp_fraction,\n            \"protect_counter\": protect_counter,\n            \"base_stats\": _BaseStatsEmbedding.embed_stats(mon),\n            \"type\": _TypeEmbedding.embed_type(mon),\n            #\"ability\": _AbilityEmbedding.embed_ability(mon),\n            #\"item\": _ItemEmbedding.embed_item(mon),\n            \"boosts\": _MonBoostsEmbedding.embed_boosts(mon),\n            \"status\": _StatusEmbedding.embed_status(mon),\n            \"effects\": _EffectsEmbedding.embed_effects(mon),\n            \"move_1\": _MoveEmbedding.embed_move(\n                available_moves[0], mon, battle.opponent_active_pokemon\n            ),\n            \"move_2\": _MoveEmbedding.embed_move(\n                available_moves[1], mon, battle.opponent_active_pokemon\n            ),\n            \"move_3\": _MoveEmbedding.embed_move(\n                available_moves[2], mon, battle.opponent_active_pokemon\n            ),\n            \"move_4\": _MoveEmbedding.embed_move(\n                available_moves[3], mon, battle.opponent_active_pokemon\n            ),\n        }\n\n    @staticmethod\n    def get_embedding() -> Space:\n        current_hp_fraction_space = Box(\n            low=-1.0, high=1.0, shape=(1,), dtype=np.float64\n        )\n        protect_counter_space = Box(low=0, high=10, shape=(1,), dtype=int)\n        return Dict(\n            {\n                \"current_hp_fraction\": current_hp_fraction_space,\n                \"protect_counter\": protect_counter_space,\n                \"base_stats\": _BaseStatsEmbedding.get_embedding(),\n                \"type\": _TypeEmbedding.get_embedding(),\n                #\"ability\": _AbilityEmbedding.get_embedding(),\n                #\"item\": _ItemEmbedding.get_embedding(),\n                \"boosts\": _MonBoostsEmbedding.get_embedding(),\n                \"status\": _StatusEmbedding.get_embedding(),\n                \"effects\": _EffectsEmbedding.get_embedding(),\n                \"move_1\": _MoveEmbedding.get_embedding(),\n                \"move_2\": _MoveEmbedding.get_embedding(),\n                \"move_3\": _MoveEmbedding.get_embedding(),\n                \"move_4\": _MoveEmbedding.get_embedding(),\n            }\n        )\n\nclass _SelfBoostsEmbedding:\n    @staticmethod\n    def embed_self_boosts(move: Move):\n        if move is None:\n            self_boosts = np.full(7, -7, dtype=int)\n            chance = np.full(7, -1, dtype=np.float64)\n        else:\n            self_boosts = np.full(7, 0, dtype=int)\n            chance = np.full(7, 0, dtype=np.float64)\n            secondary = move.secondary\n            boosts = {}\n            if move.self_boost is not None:\n                boosts.update(move.self_boost)\n            if move.target == \"self\" and move.boosts is not None:\n                if move.self_boost is not None:\n                    raise RuntimeError(\n                        \"Did not expect self_boosts and boosts to be active at the same time.\"\n                    )\n                boosts.update(move.boosts)\n            secondary_boosts = {}\n            for d in secondary:\n                if \"self\" in d.keys():\n                    data = d[\"self\"]\n                    boost_chance = d[\"chance\"] / 100\n                    if len(data) == 1 and list(data.keys()) == [\"boosts\"]:\n                        for key, value in data[\"boosts\"].items():\n                            secondary_boosts[key] = (value, boost_chance)\n            for key, value in boosts.items():\n                self_boosts[STATS[key] - 1] = value\n                chance[STATS[key] - 1] = 1.0\n            for key, value in secondary_boosts.items():\n                self_boosts[STATS[key] - 1] = value[0]\n                chance[STATS[key] - 1] = value[1]\n        return {\"boosts\": self_boosts, \"chances\": chance}\n\n    @staticmethod\n    def get_embedding() -> Space:\n        self_boosts_low_bound = [-7 for _ in range(7)]\n        self_boosts_high_bound = [6 for _ in range(7)]\n        self_boosts_space = Box(\n            low=np.array(self_boosts_low_bound, dtype=int),\n            high=np.array(self_boosts_high_bound, dtype=int),\n            dtype=int,\n        )\n        chance_low_bound = [-1.0 for _ in range(7)]\n        chance_high_bound = [1.0 for _ in range(7)]\n        chance_space = Box(\n            low=np.array(chance_low_bound, dtype=np.float64),\n            high=np.array(chance_high_bound, dtype=np.float64),\n            dtype=np.float64,\n        )\n        return Dict({\"boosts\": self_boosts_space, \"chances\": chance_space})\n\ndef embed_battle(self, battle: AbstractBattle) -> ObservationType:\n    non_active_player_mons = battle.available_switches[:]\n    non_active_opponent_mons = list(battle.opponent_team.values())\n    non_active_opponent_mons.remove(battle.opponent_active_pokemon)\n    while len(non_active_player_mons) < 5:\n        non_active_player_mons.append(None)  # noqa: used for variable length teams\n    while len(non_active_opponent_mons) < 5:\n        non_active_opponent_mons.append(None)\n    available_moves = np.full(self.space_size, 1, dtype=int)\n    int_to_move_func = self.action_to_move_func\n    for i in range(len(available_moves)):\n        try:\n            int_to_move_func(self, i, battle, InvalidAction)\n        except InvalidAction:\n            available_moves[i] = 0\n    return {\n        \"available_actions\": available_moves,\n        \"battlefield\": _BattlefieldEmbedding.embed_battlefield(battle),\n        \"active_mon\": _ActivePokemonEmbedding.embed_pokemon(\n            battle.active_pokemon, battle\n        ),\n        \"player_mon_1\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[0], battle\n        ),\n        \"player_mon_2\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[1], battle\n        ),\n        \"player_mon_3\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[2], battle\n        ),\n        \"player_mon_4\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[3], battle\n        ),\n        \"player_mon_5\": _PokemonEmbedding.embed_pokemon(\n            non_active_player_mons[4], battle\n        ),\n        \"opponent_active_mon\": _EnemyActivePokemonEmbedding.embed_pokemon(\n            battle.opponent_active_pokemon, battle\n        ),\n        \"opponent_mon_1\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[0], battle\n        ),\n        \"opponent_mon_2\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[1], battle\n        ),\n        \"opponent_mon_3\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[2], battle\n        ),\n        \"opponent_mon_4\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[3], battle\n        ),\n        \"opponent_mon_5\": _EnemyPokemonEmbedding.embed_pokemon(\n            non_active_opponent_mons[4], battle\n        ),\n    }\n"}